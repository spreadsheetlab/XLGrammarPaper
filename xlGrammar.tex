
\documentclass[conference]{IEEEtran}

%\usepackage{cite}

% correct bad hyphenation here
\hyphenation{}

\usepackage{eurosym}
\usepackage{amsfonts}
\usepackage{cite}

%\usepackage{appendix}

% Tables
\usepackage[table,xcdraw]{xcolor}
\usepackage{booktabs}
\usepackage{pbox}
\renewcommand{\arraystretch}{1.2} 
%\renewcommand*\cmidrule{} % No table middle lines
%\renewcommand{\arraystretch}{1.5} % Additional spacing with no middle lines
%\renewcommand*\cmidrule{\hdashline[1pt/2pt]}% Dashed middle lines
\renewcommand*\cmidrule{\midrule[0.001em]} % Thin table middle lines
%\renewcommand*\cmidrule{\midrule} % Thick table middle lines

%Images
\usepackage[pdftex]{graphicx}
\graphicspath{ {}{img/} }
\DeclareGraphicsExtensions{.pdf,.jpg,.png}

% Syntax package configuration
\usepackage[rounded]{syntax}
\setlength{\grammarparsep}{4pt plus 1pt minus 1pt}

\newcommand{\todo}[1]{\textbf{TODO: #1}}
\newcommand{\ignore}[1]{}

\begin{document}

\title{A LALR(1) Grammar for Excel Formulas}

\maketitle


\begin{abstract}

The abstract goes here.
\end{abstract}

\IEEEpeerreviewmaketitle


\section{Introduction}

spreadsheets as programming:
- cell calculation chains as lines of code - size, example
- avg lines of code per spreadsheet in the enron dataset

motivation: why we need a defined grammar
- parsing spreadsheet formulas, analysis, extracting metrics, finding smells, exploring the structure of spreadsheets
- refer to papers needing/referring to a simple grammar
- benefit of a simple grammar and documentation for spreadsheet users
- to explore/uncover smelly syntactical constructs that are within the grammar coverage

challenges:
- official grammar for Excel defined, but too complex/implementation specific for formula analysis
- excel is very forgiving
- grammar changes with different Excel versions, eg regular expressions support, labels in formulas now expanded to cell
references, updates in the built-in functions list

our approach:
development of grammar starting from previous work (reference to simple grammar) and analyzing the two datasets, enriching the
grammar to support everything

\section{Anatomy of Excel Spreadsheets}

Microsoft Excel is a program which allows its users to create spreadsheets.
Spreadsheets are cell-oriented dataflow programs and Excel spreadsheets are Turing complete \cite{ExcelTuringComplete}.

A single spreadsheet \emph{file} corresponds to a single (\emph{work})\emph{book}.
A workbook can contain any number of (\emph{work})\emph{sheets}.
A sheet consists of a two-dimensional grid of \emph{cells}.
The table consists or verticals \emph{rows} and horizontal \emph{columns}.
Rows are numbered sequentially top-to-bottom starting at 1, while columns are numbered left-to-right alphabetically, i.e. base-26 using A to Z as digits, starting at `A', making column 27 `AA'.

A cell can be empty or contain a constant value, \emph{formula} or \emph{array formula}.
A formula can contain constant values, operations such as multiplication with the \texttt{*} operator and \emph{function calls} such as \texttt{SUM(\ldots)}, and most importantly \emph{references} to other cells.
Function arguments are separated by a comma.

Formulas can also work with \emph{ranges}, which are a collection of cells.
Ranges can be constructed by the range operator \texttt{:} which produces a rectangular range with the two arguments as corners, the union operator \texttt{,} \footnote{This is not a mathematical union as duplicates are allowed. This operator must be placed between parentheses or curly brackets in function calls to avoid ambiguity with the argument separator which is also a comma} or the intersection operator \texttt{\char32} (a single whitespace).
The range operator is by far the most common one.
Arrays consisting of a single cell can be used where a single cell is expected.

An user can also give a name to any collection of cells thus creating a \emph{named range} thus creating an array which can be referenced in formulas by name.

\subsection{References}
The references are arguably the most important part of spreadsheets.
The value of any cell can be used in a formula by concatenating its column and row number, producing a reference like \texttt{B5}.
If a value of a cell changes this new value will be propagated to all formulas that use it.

When copying a cell to another cell by default references will be adjusted by the offset, for example copying \texttt{=A1} from cell B1 to C2 will cause the copied formula to become \texttt{=B2}.
This can be prevented by making the reference absolute by prepending a \texttt{\$} to the column index, row index or both.
The formula \texttt{=\$A\$1} will remain the same on copy while \texttt{=\$A1} will still have its row number adjusted.

An alternate style called R1C1 as opposed to the above A1 style exists, but it is very rarely seen or used by users.
In R1C1 references you specify either the offset to a cell between square brackets or its concrete location.
In R1C1 style \texttt{R[4]C[-2]} means the cell two columns to the left and four rows down, \texttt{R2C2} refers to cell B2.
The biggest advantage of R1C1 is that it causes identical formulas to be the same even when they operate on different cells or data because of their position.
This might make R1C1 useful for your purpose, but we do not support parsing it and will not discuss it any further.

\subsection{Array Formulas}

\section{Design Decisions}
trade off between ambiguity, simplicity of the grammar and usefulness of the parse trees

\section{Spreadsheet Formula Grammar}
\label{section:grammar}

\todo{Add appendix with excel function names}

All strings and characters are case-insensitive, unless otherwise noted.

\subsection{Lexical analysis}

Table \ref{table:tokens} contains an overview of the tokens produced by the scanner in our parser. The rules are given in a very simple regular expression language, but could be easily adapted for a scanner which does not support regular expression tokens. 

Our tokens also require the scanner to support token priorities. Removing the necessity for token priorities is possible by altering the tokens and production rules, but makes the grammar more complicated and the resulting tree harder to use. Leaving the tokens as-is but not providing priorities will still result in an usable grammar, but expect errors on edge cases.

\begin{table*}
\label{table:tokens}
\caption{Lexical tokens used in our grammar}
\begin{tabular}{@{}lllll@{}}
\toprule
Token Name & Description & Regular Expression & Priority & Example \\
\midrule
BINOP & Binary Operator & + $\mid$ - $\mid$ / $\mid$ * $\mid$ \textasciicircum $\mid$ \textless $\mid$ \textgreater $\mid$ = $\mid$ \textless= $\mid$ \textgreater= $\mid$ \textless \textgreater & 0 & + \\
BOOL & Boolean literal & TRUE $\mid$ FALSE & 0 & TRUE \\
CELL & Cell reference & \$? [A-Z]+ \$? [0-9]+ & 2 & $A$1 \\
ERROR & Error literal & \#NULL! $\mid$ \#DIV/0! $\mid$ \#VALUE! $\mid$   \#REF! $\mid$ \#NAME? $\mid$ \#NUM! $\mid$ \#N/A & 0 & \#REF! \\
FILE & External file reference & \textbackslash[ [0-9]+ \textbackslash] & 5 & [1]\\
add normal file names \\
FUNCTION & Excel built-in function & (Any entry from Appendix X) \textbackslash( & 5        & SUM( \\
HORIZONTAL\_RANGE & Range of rows & \$? [0-9]+ : \$? [0-9]+ & 0 & 1:4 \\
MULTIPLE\_SHEETS & Multiple sheet references &
[A-Z0-9]+ : ([A-Z0-9\_.]+ $\mid$ ' ([A-Z0-9\_ !@\#\$\%\textasciicircum{}\&*()\-+=\{\}:;$\mid$\textless\textgreater,./?\textbackslash{}\textbackslash{}] $\mid$ '')+  ') !
& 1 & Sheet1:'Escape '' 5'! \\
NAMED\_RANGE & Named range & [A-Z\_][A-Z0-9\_.]* & -2 & MYNAME \\
NAMED\_RANGE\_PREFIXED & \begin{tabular}[c]{@{}l@{}} Named range which starts with \\ a string  that could be another token \end{tabular} & (TRUE $\mid$ FALSE $\mid$ [A-Z]+[0-9]+)    {[}A-Z0-9\_.{]}+                                                                             & 3 & A1MYNAME \\
NUMBER\_LITERAL & \begin{tabular}[c]{@{}l@{}}An integer, floating point\\     or scientific notation number literal\end{tabular} & [0-9]+ ,? [0-9]* (e [0-9]+)? & 0 & 10.1e12 \\
QUOTED\_FILE\_SHEET & A file reference within single quotes & '\textbackslash[ [0-9]+ \textbackslash] ([0-9A-Z\_ !@\#\$\%\textasciicircum{}\&*()\-+=\{\}:;$\mid$\textless\textgreater,./?\textbackslash{}\textbackslash{}] $\mid$ '')+ '!
& 5        & '{[}1{]}My Sheet'! \\
REFERENCE\_FUNCTION & Excel built-in reference function & (INDEX $\mid$ OFFSET $\mid$ INDIRECT)\textbackslash( & 5 & INDEX( \\
RESERVED\_NAME & An Excel reserved name & \_xlnm\textbackslash.  [A-Z\_]+ & -1 & \_xlnm.History \\
SHEET & The name of a worksheet &
	([0-9A-Z\_.]+ $\mid$ ' ([0-9A-Z\_ !@\#\$\%\textasciicircum{}\&*()\-+={}$\mid$:;\textless\textgreater,./?\textbackslash\textbackslash] $\mid$ '')+ ') !
& 5        & Sheet1!            \\
STRING & String literal & " ([\textasciicircum{} "] $\mid$ "")* " & 0        & "He Said: ""Hi"""  \\
UNOP\_PREFIX & Unary postfix operator & \% & 0 & \% \\
UNOP\_POSTFIX & Unary prefix operator & + $\mid$ - & 0 & -                  \\
UDF & User Defined Function & (\_xll\textbackslash.)? [A-Z0-9]+  ( & 4 & MyFunction( \\
VERTICAL\_RANGE & Range of columns & \$? [A-Z]+ : \$? [A-Z]+ & 0 & A:Z \\ 
\bottomrule
\end{tabular}
\end{table*}

\subsection{Production rules}

We define our production rules in Extended BNF syntax. The start symbol is $Start$. If one does not wish to accept array formula's and wishes to omit the `=' at the start of a formula $Formula$ can be used as a start symbol instead, or the $Start$ non-terminal can be adjusted.

\begin{grammar}
<Start> ::= <Constant>
	\alt '=' <Formula>
	\alt <ArrayFormula>
	
<ArrayFormula> ::= `\{=' <Formula> `\}'

<Formula> ::= Constant
         \alt Reference
         \alt FunctionCall
         \alt `(' Formula `)'
         \alt ConstantArray
         \alt "RESERVED_NAME"
         
<Constant> ::= "NUMBER"
         \alt "STRING"
         \alt "BOOL"
         \alt "ERROR"
         
<FunctionCall> ::= Function Arguments `)'
		\alt "UNOP_PREFIX" Formula
		\alt Formula "UNOP_POSTFIX"
		\alt Formula "BINOP" Formula

<Function> ::= "FUNCTION"
	\alt "UDF"
	
<Arguments> ::= Argument
\alt Argument `,' Arguments

<Argument> ::= Formula | $\epsilon$

%<Error> ::= "ERROR"
%
%<String> ::= "STRING"
%
%<QuotedFileSheet> ::= "QUOTED_FILESHEET"
%
%<Sheet> ::= "SHEET"
%
%<MultipleSheets> ::= "MULTIPLE_SHEETS"


%<File> ::= "FILE"


<Reference> ::= <ReferenceItem>
	\alt <Reference> `:' <Reference>
	\alt <Reference> `\ ' <Reference>
	\alt `(' <References> `)'
	\alt <Prefix> <ReferenceItem>
    \alt <Prefix> "UDF" <Arguments> `)'
    
<ReferenceItem> ::= "CELL"
	\alt <NamedRange>
	\alt "REFERENCE_FUNCTION" Arguments `)'
	\alt "VERTICAL_RANGE"
	\alt "HORIZONTAL_RANGE"
	\alt "ERROR"
	
<Prefix> ::= "SHEET"
	\alt "FILE" "SHEET"
	\alt "FILE" `!'
	\alt "QUOTED_FILE_SHEET"
	\alt "MULTIPLE_SHEETS"
	\alt "FILE" "MULTIPLE_SHEETS"
	
<NamedRange> ::= "NAMED_RANGE"
            \alt "NAMED_RANGE_PREFIXED"

<References> ::= Reference
	\alt Reference `,' References

<ConstantArray> ::= `\{' ArrayColumns `\}'

<ArrayColumns> ::= <ArrayRows>
	\alt <ArrayRows> `;' <ArrayColumns>

<ArrayRows> ::= <Constant>
	\alt <Constant> `,' <ArrayRows>

\end{grammar}

\subsection{Precedence}

All operators in Excel are left-associative, including the exponentiation operator. In order for our grammar to be unambiguous a separate operator precedence needs to be defined, which can be found in Table \ref{table:operatorprec}

\begin{table}
\label{table:operatorprec}
\caption{Operator precedence in Excel Formulas}
\begin{tabular}{lr}
Operator                                                                & Precedence \\
 & higher = greater \\
= \textless \  \textgreater \  \textless= \  \textgreater= \  \textless\textgreater & 1          \\
\&                                                                      & 2          \\
+ - (binary)                                                            & 3          \\
* /                                                                     & 4          \\
\textasciicircum                                                        & 5          \\
\%                                                                      & 6          \\
+ - (unary)                                                             & 7          \\
: \texttt{\char32}                                                             & 8         
\end{tabular}
\end{table}

Putting the operator precedence directly into the grammar is relatively easy (and can be automated), but makes the grammar less clear and compact.

\subsection{Ambiguity}

Unfortunately our grammar is not fully unambiguous, because we made a trade-off between avoid ambiguity, simplicity of the grammar and usefulness of the resulting trees. The following ambiguities are present and must be manually resolved using the methods your parser generator provides:

\synt{FunctionCall} and \synt{ArrayAsArgument} can conflict when only one argument is present. \synt{Functioncall} is the correct parse. Example ambiguous sentence: \texttt{=SUM((1))}.

\synt{FunctionCall} and \synt{Reference} can conflict when a bracketed reference is present where any formula can be present. Either parse is correct as they are logically equivalent, but we recommend parsing this as \synt{FunctionCall}. Example ambiguous sentence: \texttt{=(A1)}.

\subsection{Internationalization}

\todo{Move to discussion maybe?}

Excel formulas differ depending on the language of the software. For example function arguments are separated by a semicolon instead of a comma in locales that use the comma as a decimal separator.

Our grammar is only for the default (English) locale. Grammars for other locales can be gotten by replacing delimiters, error values and function names by their localized versions.

It is worth noting that Excel will always save formulas in either a locale-independent binary format (Excel 2003 and earlier) or in its English version (Excel 2007 and later). When interacting with Excel through its API 2 versions of the formula can be read or written: the English version and the version in the current locale.

\subsection{Intersection operator}

\todo{Probably not worth its own section}

The intersection binary operator in Excel formulas is a single space, while the rest of the language is mostly whitespace independent.
Care must thus be taken on this point when implementing this grammar.

If your parser supports implicit operators the intersection operator can be implemented this way.
An example of implicit operators outside of Excel formulas is in calculus where multiplication is often omitted and $5a$ is equivalent to $5 \cdot a$ thus making $\cdot$ an implied operator.


\section{Evaluation}
The grammar is implemented in the Irony parser generator framework \footnote{https://irony.codeplex.com/} and the resulting parser is available for download \footnote{link for download}.

To evaluate the grammar we use it to parse a total of 1,061,360 formulas. Those were found in the two major datasets available in the spreadsheet research community: The Euses dataset \cite{euses}, comprising of 4,498 spreadsheets and the Enron email corpus \cite{enron}, which became available after the Enron company declared bankruptcy, comprising of 16,190 spreadsheets. We were not able to process 1087 (5.25\%) of these spreadsheets, either because they are password protected or because of failures due to the Gembox third party library that we use for opening them. In total, the 19,601 spreadsheets that were processed from the two datasets include 23,559,993 formula cells. These are grouped into 1,061,360 sibling classes (i.e., groups of cells that share the same formula in the R1C1 style), and this is the number of formulas that were used as input to the parser.

To extract formulas and feed them to the parser we built a tool that opens spreadsheets, reads all their cells and identifies which cells have the same formula in R1C1. The tool selects the first cell from each sibling class and uses its formula string as input to the parser. It parses only one cell from each sibling class - the only differences between the formulas in a sibling class are the values of the references, so the structure of the produced abstract syntax trees is exactly the same. The abstract syntax trees are then traversed to generate a variety of information, for example, the references of cells to other cells, the functions that are used, the operations that are performed and the fixed numbers in the formulas.

Processing the two datasets and extracting those results in a standard machine with Intel Core i7 processor and 16GBs of memory takes about 4 hours.

\begin{figure*}
\centering
\begin{grammar}
	<Reference> ::= \[[
	\begin{stack} '$($' <Reference> '$)$'\\ <Reference> \begin{stack} '$:$' \\ '$ $' \end{stack} <Reference> \\
	\begin{stack} \\ \begin{stack} \\ "FILE" \end{stack} \begin{stack} "SHEET" \\ "MULTIPLE_SHEETS" \end{stack} \\ "FILE" '$!$' \\ "QUOTED_FILE_SHEET" \end{stack}
	\begin{stack} \begin{stack} \begin{stack} "CELL" \\ "REFERENCE-FUNCTION" <Arguments> '$)$' \end{stack} \\ "VERTICAL-RANGE" \\ "HORIZONTAL-RANGE" \\ \begin{stack} "NAMED-RANGE" \\ "NAMED-RANGE-COMBINED" \end{stack} \\ "ERROR" \end{stack} \\ "UDF" <Arguments> '$)$'\end{stack}
	\end{stack}
	\]]
\end{grammar}
\end{figure*}

\section{Wacky Grammar}
The grammar resulted from many cycles of parse errors, enrichments and refinements. There are parts of the grammar that cover a particularly complex set of structures, and these are the ones that are analyzed further in this section.

\begin{table*}
	\label{table:occurences}
	\caption{Frequency of spreadsheet formulas with specific grammatical structures in the Euses and Enron datasets}
	\begin{tabular}{llrrrrrrr}
		Non-terminal & Example & euses &  &  & enron &  & \\
		&  & 1st siblings& formula cells &  & 1st siblings& formula cells & \\
		\hline
		Formula & \texttt{=1+2} & 95,693 & 1,459,263 & 0.00\% & 965,622 & 22,098,761 & 0.00\%\\
		Reference & \texttt{=E9/E10} & 86,291 & 1,443,464 & 98.92\% & 901,596 & 21,938,254 & 99.27\%\\
		Cell & \texttt{=A5} & 84,929 & 1,440,266 & 98.70\% & 892,390 & 21,827,669 & 98.77\%\\
		CellReferenceFunction & \texttt{=SUM(J9:INDEX(J9:J41,B43))} & 846 & 67,072 & 4.60\% & 10,586 & 723,460 & 3.27\%\\
		NamedRange & \texttt{=SUM(freq)} & 1,598 & 22,846 & 1.57\% & 21,112 & 1,704,791 & 7.71\%\\
		Prefix & \texttt{=Sheet1!B1} & 29,257 & 439,725 & 30.13\% & 313,889 & 5,458,890 & 24.70\%\\
		Sheet & \texttt{=Sheet1!B1} & 28,308 & 437,110 & 29.95\% & 281,186 & 5,144,043 & 23.28\%\\
		File & \texttt{=[11]Sheet1!C5} & 1,391 & 8,472 & 0.58\% & 102,449 & 1,126,446 & 5.10\%\\
		FileOnlyPrexix & \texttt{=[1]!today} & 264 & 655 & 0.04\% & 1,777 & 27,794 & 0.13\%\\
		QuotedFileSheet & \texttt{=('[2]Detail I\&E'!D62)/1000} & 680 & 1,746 & 0.12\% & 33,006 & 324,588 & 1.47\%\\
		MultipleSheets & \texttt{=SUM(Sheet1:Sheet20!I29)} & 9 & 234 & 0.02\% & 164 & 1,752 & 0.01\%\\
		Bool & \texttt{=IF(AND(R11=1,R14=TRUE),G19,0)} & 672 & 32,802 & 2.25\% & 6,925 & 1,249,218 & 5.65\%\\
		ErrorReference & \texttt{=AVERAGE(\#REF!)} & 683 & 20,774 & 1.42\% & 3,547 & 133,377 & 0.60\%\\
		Text & \texttt{=COUNTIF(B$4:B$46,>=90)} & 9,402 & 156,907 & 10.75\% & 50,490 & 2,685,412 & 12.15\%\\
		Number & \texttt{=(B8/48)*15} & 24,989 & 341,531 & 23.40\% & 231,594 & 7,954,999 & 36.00\%\\
		VRange & \texttt{=COUNT(K!A:A)} & 322 & 1,805 & 0.12\% & 547 & 55,177 & 0.25\%\\
		Hrange & \texttt{=MATCH(F3,Prices!2:2,0)} &  &  & 0.00\% & 14 & 839 & 0.00\%\\
		UDFReference & \texttt{=[1]!wbname()} & 251 & 608 & 0.04\% & 81 & 247 & 0.00\%\\
		Function & \texttt{=SUM(A5:A22)} & 40,908 & 770,280 & 52.79\% & 264,245 & 10,329,456 & 46.74\%\\
		ExcelFunction & \texttt{=SUM(A5:A22)} & 40,501 & 759,317 & 52.03\% & 258,494 & 10,199,344 & 46.15\%\\
		UDF & \texttt{=SQRT(_eoq2(C5,C4,C6,C7))} & 742 & 12,811 & 0.88\% & 24,635 & 345,405 & 1.56\%\\
		ArrayFormula & \texttt{=FVSCHEDULE(1,{0.09;0.11;0.1})} & 15 & 19 & 0.00\% &  &  & 0.00\%\\
		ReservedName & \texttt{=C23/_xlnm.Print_Area} & 7 & 8 & 0.00\% & 51 & 302 & 0.00\%\\
		EmptyArgument & \texttt{=DCOUNT(Lettergrades,,I80:I81)} & 128 & 3,614 & 0.25\% & 1,225 & 7,138 & 0.03\%\\
		ArrayAsArgument & \texttt{=LARGE((F38,C38),1)} & 1 & 34 & 0.00\% & 9 & 351 & 0.00\%\\
		PrefixOp & \texttt{=+B11+1} & 7,821 & 61,903 & 4.24\% & 214,182 & 3,308,311 & 14.97\%\\
		PostfixOp & \texttt{=IF(E5>I8,3\%,0\%)} & 215 & 1,091 & 0.07\% & 666 & 15,560 & 0.07\%\\
		InfixOp & \texttt{=H10-H8} & 39,325 & 567,228 & 38.87\% & 368,020 & 13,466,887 & 60.94\%\\
		\hline
		Prefixed right limits & \texttt{=SUM('Total-1'!\$B8:'Total-1'!B8)} & 108 & 941 & 0.06\% & 39 & 560 & 0.00\%\\
		_xll. & \texttt{=_xll.RiskTriang(F9,F7,F8)} & 16 & 89 & 0.01\% & 12,998 & 170,661 & 0.77\%\\
		_xlnm. & \texttt{=C23/_xlnm.Print_Area} & 7 & 8 & 0.00\% & 65 & 316 & 0.00\%\\
		ranges with more than two limits & \texttt{=SUM(I8:K8:M8)} &  &  & 0.00\% & 357 & 8,566 & 0.04\%\\
		ParenthesizedReference & \texttt{=(2*(B29))/(1+B29)} & 810 & 5,834 & 0.40\% & 4,676 & 89,886 & 0.41\%\\
		SimpleRangeReference & \texttt{=SUM(A5:A22)} & 26,194 & 473,491 & 32.45\% & 164,322 & 3,584,966 & 16.22\%\\
		intersect & \texttt{=Ending_Inventory Jan} & 207 & 2,098 & 0.14\% & 197 & 348 & 0.00\%\\
		ContentInFile & \texttt{=[1]!'SGJ200,LA'} & 121 & 254 & 0.02\% & 3,155 & 3,432 & 0.02\%\\
	\end{tabular}
\end{table*}

\subsection{References}
 
Spreadsheet formulas allow for many different types of references, including single cell references, cell ranges, horizontal or vertical ranges, named ranges and reference-returning build-in or user-defined functions. All of these references can be internal (in the same or in different sheets) or external. Syntactically, they can be expressed in a number of ways. The simplest case of a reference to a cell range can be expressed in any of the following ways:

\begin{eqnarray*}
&SUM&(A1:A2) \\
= &SUM&(Sheet1!A1:A2) \\
= &SUM&(Sheet1!A1:(A2)) \\
= &SUM&('Sheet1'!A1:A2) \\
= &SUM&(Sheet1!A1:Sheet1!A2) \\
= &SUM&(Sheet1!A1:'Sheet1'!A2) \\
\end{eqnarray*}

The <Reference> rule covers all those types of referencing expressions. It was the rule that was the most complex to devise to cover all edge cases in the two datasets.
 
how often each case is used:
- SUM(Sheet2:Sheet3!A1)
- [1]!Hub\_Consolidation
- Functions returning references (INDEX|OFFSET|INDIRECT|???) SUM(A1:INDEX(A:A,1,1:1))
- External UDFs RIGHT([1]!SheetName(),(LEN([1]!SheetName())-20))
- Prefixed right limits =SUM(Deals!F9:'Deals'!F16)
- This thing we do not know what it is =BLP|M!'INDU Index,[PX\_close\_5d]'

\subsection{Arrays}
Array formulas
- IF(OR(MONTH(GQ2) = {3,9}), IF(ABS(SUM(GQ223) - GQ225)>0.001,1,0), 0)
Arrays used as arguments
- LARGE((F38,C38),1)

\subsection{Reserved names}
- Add-in functions C9*\_xll.HEAT(B9,C9)
- \_xlnm.* =SUMIF('150000'!A:A,\_xlnm.Print\_Titles,'150000'!C:C)


\subsection{Smelly grammar constructs}
 + how often they are used
- Implicit intersect operator =COUNT(A1:A10˽A1:A5)
- Complex ranges =SUM(I8:namedRange:M8)
- Combinations of the above SUM((Total\_Cost Jan):(Total\_Cost Apr.))

\section{Discussion and Limitations}

Out of the 1,061,360 formulas from the two datasets that were used as input to the parser, 1,058,050 (99.69\%) were parsed successfully. The formulas that were not parsed using the grammar defined in Section \ref{section:grammar} are:

\begin{itemize}
	\item 3,276 cases of external file references without cell targets, e.g. \texttt{=[1]!'SGJ200,LA'}. The grammar does not provide support for those cases because we do not yet understand what those formulas mean and how they are evaluated from Excel.
	\item formulas \texttt{=-NOX, Regi} and \texttt{=-_SO2, Regi} in two different sheets in the Enron dataset. None of those formulas is evaluated from Excel, which returns a \texttt{\#NAME?} error.
	\item formula \texttt{=+Ë‰} was included in an Enron file that we assume to be corrupt, as it only included similarly formatted characters.
	\item 31 cases of formulas that are not returned correctly from the Gembox third party library that we use for opening spreadsheets -e.g., our tool reads and attempts to parse formula \texttt{IF(=7,AVERAGE(C4:C11),0)} and fails, but in reality the formula is \texttt{IF(B8=7,AVERAGE(C4:C11),0)} which does parse. All these 31 cases are parsed successfully when we manually provide them as input to the parser.
\end{itemize}

The formulas of the first case are therefore the only legitimate ones -in terms of Excel coverage and evaluation- that were found in the two datasets and that the proposed grammar does not support. (discuss! exists in other systems?)

\subsection{Limitations}
todo: check if the features below are supported in other spreadsheet systems

The evaluation of the grammar does not include array formulas. Those are specified as formulas surrounded by brackets, for example \texttt{\{= SUM( A1:E1*\{1,2,3,4,5\})\}}, that perform multiple calculations on array items. The grammar is designed to recognize array formulas as regular formulas surrounded by brackets (<ArrayFormula> rule). However, due to limitations of the third party library that our tool uses for reading the formulas from the spreadsheets, array formulas are read and fed to the parser as regular formulas, without the surrounding brackets. For this reason, we can neither evaluate this case in terms of grammar support, nor can we extract information on their frequency in the two datasets.

Other limitations of the proposed grammar concern syntactical features that have been discontinued, like regular expressions in formulas. Excel allows defining formulas that include regular expressions, for example \texttt{=SUM('S*'!A1)} or \texttt{=SUM('Sheet?'!A1)}. However, in Excel 2010 and up (are we sure???), regular expressions are instantly resolved -in the example, to \texttt{=SUM(Sheet2:Sheet3!A1)}, where the sheets are all matching sheets, except the one that this formula is on. This way, in latest versions of Excel, saved spreadsheets never contain regular expressions. Also in the two datasets there was no such case, even though ??\% of the spreadsheets are in prior to Excel 2007 format (.xls files). 

The use of labels in formulas (a.k.a. natural language formulas) is another feature that was discontinued in Excel 2007. Labels were the headings that were typed above rows and columns, and they could be used in formulas instead of defined names or cell ranges. For example, formula \texttt{=Product A First Quarter} would return the intersection between the cell range with heading \texttt{Product A} and the one with heading \texttt{=First Quarter}. This feature is replaced in newer versions of Excel with the less error-prone named ranges feature. The proposed grammar does not support it, and it would mistakenly parse the labels as named ranges.

\subsection{Exploitation}
The abstract syntax trees that the parser produces are traversed to generate information like the references of cells to other cells -in the form of internal or external ranges of any kind, the types of functions used, the operations and the fixed numbers in formulas. This information is used to perform more complex calculations on the cell dependencies, the calculation chains and possible smells on those. The parser has already been used in reference \cite{EnronVSEuses} to extract information like the intra-worksheet connections, the external links, the transitive precedents and the preceding cells of formulas. Also, in ???? (other published work?)

\section{Comparison against the LibreOffice grammar}

\section{Related work}

\section{Conclusion}
The conclusion goes here.


\section*{Acknowledgment}
The authors would like to thank...


\bibliographystyle{IEEEtran}
\bibliography{XLGrammarRefs}



\end{document}


