
\documentclass[conference]{IEEEtran}

%\usepackage{cite}

% correct bad hyphenation here
\hyphenation{}

\usepackage{eurosym}
\usepackage{amsfonts}
\usepackage{cite}

% Modern encoding and fonts
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

%\usepackage{appendix}

% Tables
\usepackage{tablefootnote}
\usepackage[table,xcdraw]{xcolor}
\usepackage{booktabs}
\usepackage{pbox}
\renewcommand{\arraystretch}{1.2} 
%\renewcommand*\cmidrule{} % No table middle lines
%\renewcommand{\arraystretch}{1.5} % Additional spacing with no middle lines
%\renewcommand*\cmidrule{\hdashline[1pt/2pt]}% Dashed middle lines
\renewcommand*\cmidrule{\midrule[0.001em]} % Thin table middle lines
%\renewcommand*\cmidrule{\midrule} % Thick table middle lines

%Images
\usepackage[pdftex]{graphicx}
\graphicspath{ {}{img/} }
\DeclareGraphicsExtensions{.pdf,.jpg,.png}

%\renewcommand{\figurename}{Grammar}

% Syntax package configuration
\usepackage[rounded]{syntax}
\setlength{\grammarparsep}{4pt plus 1pt minus 1pt}

\newcommand{\todo}[1]{\textbf{TODO: #1}}
\newcommand{\ignore}[1]{}


\begin{document}
\title{A Grammar for Spreadsheet Formulas\\Evaluated on Two Large Datasets}

\author{\IEEEauthorblockN{Efthimia Aivaloglou, David Hoepelman, Felienne Hermans}
	\IEEEauthorblockA{Software Engineering Research Group\\
		Delft University of Technology\\
		Mekelweg 4, 2628 CD Delft, the Netherlands\\
		e.aivaloglou@tudelft.nl, d.j.hoepelman@student.tudelft.nl, f.f.j.hermans@tudelft.nl}
}
\maketitle

\begin{abstract}
Spreadsheets are ubiquitous in the industrial world and often perform a role similar to other computer programs in many different domains.
However, there does not exist a reliable grammar that is concise enough to facilitate research on spreadsheet formula code bases.
This paper presents a grammar for spreadsheet formulas that is compatible, is compact enough to feasibly implement with a parser generator, and produces parse trees suited for further manipulation and analysis. 
We evaluate the grammar against more than one million unique formulas extracted from the well known EUSES and Enron spreadsheet datasets, successfully parsing 99.99\%.
Additionally, we utilize the grammar to analyze these datasets and measure the frequency of usage of language features in spreadsheet formulas.
Finally, we identify smelly constructs and edge cases in the syntax of formulas.
\end{abstract}

\IEEEpeerreviewmaketitle

\section{Introduction}
Spreadsheets are widely used in industry: Winston~\cite{Wins2001} estimates that 90\% of all analysts in industry perform calculations in
spreadsheets. Their use is diverse, ranging from inventory administration to educational applications and from scientific
modeling to financial systems. It is estimated that 90\% of desktops have Excel installed\cite{DBLP:conf/icse/BradleyM09} and that the number of spreadsheet programmers is bigger than that of software programmers\cite{DBLP:conf/vl/ScaffidiSM05}. 

Because of their widespread use, they have been the topic of research since the nineties\cite{DBLP:journals/sigplan/BellP93}. Recent spreadsheet research has often focused on analyzing spreadsheets. For example, there have been attempts to visualize spreadsheets ~\cite{DBLP:conf/icse/HermansPD11, Shio1999}. More recently, researchers have attempted to define \emph{spreadsheet smells}: applications of Fowler's code smells to spreadsheets~\cite{DBLP:conf/icse/HermansPD12, DBLP:conf/icsm/Hermans212}, followed by approaches to refactor spreadsheets~\cite{hermans2014bumblebee,badame2012refactoring}.

These research works analyze the formulas within spreadsheets, and therefore often parse the formulas. This is done either by using simple grammars which have not been evaluated (\cite{badame2012refactoring}), or through implied, undefined grammars(\cite{DBLP:conf/icse/HermansPD11,DBLP:conf/icse/HermansPD12, DBLP:conf/icsm/Hermans212, hermans2014bumblebee}). The above analyses are our main motivation towards a defined grammar. It will enable parsing spreadsheet formulas into processable parse trees which can in turn be used to analyze cell references, extract metrics, find code smells and explore the structure of spreadsheets. Essentially, a reliable grammar can facilitate research on the spreadsheet formula code bases. Furthermore, research towards defining and verifying a formula grammar can facilitate exploring and possibly uncovering smelly syntactical constructs that are within the grammar coverage.

To make a grammar suitable for these goals, the requirements that we set for it are (1) to be compatible with the official Excel formula language, (2) to produce parse trees suited for further manipulation and analysis, and (3) to be compact enough to feasibly implement with a parser generator. The approach that we took towards developing the grammar was gradual enrichment through trial-and-error: we started from a simple grammar containing only the well known formula structures, implemented its parser, and provided as input to it formulas extracted from spreadsheet datasets. We used the two major datasets that are available in the spreadsheet research community: The EUSES dataset \cite{euses} and the Enron corpus \cite{enron}, jointly containing over 20,000 spreadsheets. The final grammar resulted from many cycles of parse errors, enrichments and refinements, until all common and rare cases found in the datasets were supported.

The contributions of this paper are (1) a concise grammar for spreadsheet formulas, (2) the evaluation of the compatibility of the grammar using two major datasets, and (3) an analysis of the common formula characteristics and of the rare grammatical cases of the datasets.

The remainder of the paper is organized as follows: In the following section we summarize the basic concepts of spreadsheets and of the formula language. In Section \ref{section:grammar} we present the spreadsheet formula grammar, its lexical and syntactical analysis rules, and details on precedence and ambiguity. Section \ref{sec:evaluation} explains how we implemented and evaluated the grammar, presents the obtained results, and analyses the datasets' formula characteristics. In Section \ref{sec:discussion} we discuss the grammar and its limitations. Section \ref{section:relatedWork} presents related work and Section \ref{section:conclusion} concludes the paper.

\section{Background}

Spreadsheets are cell-oriented dataflow programs which are Turing complete \cite{ExcelTuringComplete}.

A single spreadsheet \emph{file} corresponds to a single (\emph{work})\emph{book}.
A workbook can contain any number of (\emph{work})\emph{sheets}.
A sheet consists of a two-dimensional grid of \emph{cells}.
The grid consists or verticals \emph{rows} and horizontal \emph{columns}.
Rows are numbered sequentially top-to-bottom starting at 1, while columns are numbered left-to-right alphabetically, i.e. base-26 using A to Z as digits, starting at `A', making column 27 `AA'.

A cell can be empty or contain a \emph{constant value}, a \emph{formula} or an \emph{array formula}.
Formulas consist of expressions which can contain constant values, arithmetic operators and \emph{function calls} such as \texttt{SUM(\ldots)} and, most importantly, \emph{references} to other cells.
Function arguments are separated by commas.

\subsection{References}
References are the core component of spreadsheets.
The value of any cell can be used in a formula by concatenating its column and row number, producing a reference like \texttt{B5}.
If the value of a cell changes this new value will be propagated to all formulas that use it.

When copying a cell to another cell by default references will be adjusted by the offset, for example copying \texttt{=A1} from cell B1 to C2 will cause the copied formula to become \texttt{=B2}.
This can be prevented by making the reference absolute by prepending a \texttt{\$} to the column index, row index or both.
The formula \texttt{=\$A\$1} will remain the same on copy while \texttt{=\$A1} will still have its row number adjusted.

An alternate style called R1C1 as opposed to the above A1 style exists, but it is very rarely seen or used by users.
In R1C1 references one specifies either the offset to a cell between square brackets or its concrete location.
In R1C1 style \texttt{R[4]C[-2]} means the cell two columns to the left and four rows down, while \texttt{R2C2} refers to cell B2.
The biggest advantage of R1C1 is that it causes identical formulas to be the same even when they operate on different cells or data because of their position.
These properties make R1C1 useful as an internal representation, but the grammar presented in this paper is intended for the common A1 reference style.

References can also be \emph{ranges}, which are collections of cells.
Ranges can be constructed by three operators: the range operator \texttt{:}, the union operator \texttt{,} (a comma) and the intersection operator \texttt{\char32} (a single whitespace).
The range operator creates a rectangular range with the two cells as top-left and bottom-right corners, so \texttt{=SUM(A1:B10)} will sum all cells in columns A and B with row number 1 through 10.
The range operator is also used to construct ranges of whole rows or columns, for example \texttt{3:5} is the range of the complete rows three through five, and \texttt{A:D} is the range of columns A through D.
The union operator, which is different from the mathematical union as duplicates are allowed, combines two references, so \texttt{A1,C5} will be a range of two cells, \texttt{A1} and \texttt{C5}.
Lastly the intersection operator takes only the cells which are in both arguments, \texttt{=A:A 5:5} will thus be equivalent to \texttt{=A5}.

A user can also give a name to any collection of cells, thus creating a \emph{named range} which can be referenced in formulas by name.

\subsection{Sheet and external references and DDE}
\label{subsection:ExternalRefsDDE}

By default references are to cells or ranges in the same sheet as the formula, but this can be modified with a prefix. A prefix consists of some identifier, followed by an exclamation mark followed by the actual reference.

The most common use case is to reference another sheet in the same workbook, where the prefix is simply the sheetname: \texttt{=Sheetname!A1}. References to external spreadsheet files are also possible, which is done by prepending the file name in between square brackets: \texttt{=[Filename]Sheetname!A1} or \texttt{=[Filename]!NamedRange}.
A peculiar type of prefix are those that indicate multiple sheets: \texttt{=Sheet1:Sheet10!A1} means A1 in Sheet1 through Sheet10.
Sheet names can also be between single quotes: \texttt{='Sheetname with space'!A1}. 

In Windows versions of Microsoft Excel formulas can also call external programs through Dynamic Data Exchange (DDE). DDE links are a special case of references, used for receiving data from other applications. They take the form of \texttt{=Program|Topic!Arguments}, e.g. \texttt{=Database|TableA!Column1}.

\subsection{Array Formulas and Arrays}
\label{sec:arrayformulas}
In spreadsheet programs it is possible to work with one- or two-dimensional matrices.

When constructed from constant values they are called \emph{array constants}, e.g. \texttt{\{1,2;3,4\}}.
They are surrounded by curly brackets, columns are separated by commas, and rows by semicolons.
Several matrix operations are available, for example \texttt{=SUM(\{1,2,3\}*10)} will evaluate to 60.

\emph{Array Formulas} use the same syntax as normal formulas, except that the user must enter \emph{Ctrl} + \emph{Shift} + \emph{Enter} to signal that it is an Array formula.
Excel and LibreOffice surround the formula with curly braces.
Google docs works differently and requires the user to surround an array formula with \texttt{ARRAYFORMULA($\ldots$)}.

Marking a formula as an array formula will enable one- or two-dimensional ranges to be treated as array.
For example if \texttt{A1},\texttt{A3},\texttt{A3} contain the values \texttt{1},\texttt{2},\texttt{3} the array formula \texttt{\{=SUM(A1:A3*10)\}} will evaluate to \texttt{60}. Furthermore, an array formula allows the user to return multiple results, which will be presented in multiple cells.
The array formula \texttt{\{=\{1,2,3\}*\{4,5,6\}\}} will show \texttt{4}, \texttt{10} and \texttt{18} in three different cells.

\section{Spreadsheet Formula Grammar}
\label{section:grammar}

For previous and ongoing research the authors needed a grammar for Microsoft Excel spreadsheet formulas with the following requirements:

\label{sec:designgoals}
\begin{enumerate}
\item Be compatible with the official language
\item Produce a parse tree suited for further manipulation and analysis with minimal post-processing required
\item Be compact enough to feasibly implement with a parser generator
\end{enumerate}

While an official grammar for Excel formulas is published \cite{ExcelOfficialGrammar}, it does not meet the above requirements for two reasons.
Firstly, it is over 30 pages long and thus fails requirement 3.
Secondly, because of the detail of the grammar and the large number of production rules the resulting parse trees fail requirement 2.

For this reason the authors decided to construct their own grammar based with the above requirements as \emph{design goals}.

\subsection{Grammar class}

The class of this grammar is LALR(1), which was motivated by the available tool support and relative few restrictions as opposed to LL(1) or recursive-dependent parsers, which supports design goals 2 and 3.
Generalized LR grammar parser generators provide more freedom, but were not chosen because of lack of suitable tools for our target environment.

\begin{table*}
\label{table:tokens}
\caption{Lexical tokens used in our grammar}
\begin{tabular}{@{}llll@{}}
\toprule
Token Name & Description & Regular Expression & Priority \\
\midrule
%BINOP & Binary Operator & + $\mid$ - $\mid$ / $\mid$ * $\mid$ \textasciicircum $\mid$ \textless $\mid$ \textgreater $\mid$ = $\mid$ \textless= $\mid$ \textgreater= $\mid$ \textless \textgreater & 0 & + \\
BOOL & Boolean literal & TRUE $\mid$ FALSE & 0 \\
CELL & Cell reference & \$? [A-Z]+ \$? [0-9]+ & 2 \\
DDECALL & Dynamic Data Exchange & ' ([A-Z0-9\_ !@\#\$\%\textasciicircum{}\&*()\-+=\{\}:;$\mid$\textless\textgreater,./?\textbackslash{}\textbackslash{}] $\mid$ '')+ ' & 0 \\
ERROR & Error literal & \#NULL! $\mid$ \#DIV/0! $\mid$ \#VALUE! $\mid$ \#NAME? $\mid$ \#NUM! $\mid$ \#N/A & 0 \\
ERROR-REF & Reference error literal & \#REF! & 0 \\
FILE & External file reference & \textbackslash[ [0-9]+ \textbackslash] & 5 \\
FUNCTION & Excel built-in function & (Any entry from the function list\tablefootnote{A function list is available as part of the reference implementation. Lists provide by Microsoft are also available in \cite{ExcelFunctionReference} and \cite{ExcelOfficialGrammar}.}) \textbackslash( & 5        \\
HORIZONTAL-RANGE & Range of rows & \$? [0-9]+ : \$? [0-9]+ & 0 \\
MULTIPLE-SHEETS & Multiple sheet references & \begin{tabular}[c]{@{}l@{}}
[A-Z0-9]+ : ([A-Z0-9\_.]+$\mid$'([A-Z0-9\_ !\textasciicircum{}\&*()\-+=\{\}:;$\mid$\textless\textgreater,./?\textbackslash{}\textbackslash{}] $\mid$ '')+')!
\end{tabular}
& 1 \\
NAMED-RANGE & Named range & [A-Z\_][A-Z0-9\_.]* & -2 \\
NAMED-RANGE-PREFIXED & \begin{tabular}[c]{@{}l@{}} Named range which starts with \\ a string  that could be another token \end{tabular} & (TRUE $\mid$ FALSE $\mid$ [A-Z]+[0-9]+)    {[}A-Z0-9\_.{]}+                                                                             & 3 \\
NUMBER-LITERAL & \begin{tabular}[c]{@{}l@{}}An integer, floating point\\     or scientific notation number literal\end{tabular} & [0-9]+ ,? [0-9]* (e [0-9]+)? & 0 \\
QUOTED-FILE-SHEET & A file reference within single quotes & '\textbackslash[ [0-9]+ \textbackslash] ([0-9A-Z\_ !@\#\$\%\textasciicircum{}\&*()\-+=\{\}:;$\mid$\textless\textgreater,./?\textbackslash{}\textbackslash{}] $\mid$ '')+ '!
& 5        \\
REFERENCE-FUNCTION & Excel built-in reference function & (INDEX $\mid$ OFFSET $\mid$ INDIRECT)\textbackslash( & 5 \\
RESERVED-NAME & An Excel reserved name & \_xlnm\textbackslash.  [A-Z\_]+ & -1 \\
SHEET & The name of a worksheet &
	([0-9A-Z\_.]+ $\mid$ ' ([0-9A-Z\_ !@\#\$\%\textasciicircum{}\&*()\-+={}$\mid$:;\textless\textgreater,./?\textbackslash\textbackslash] $\mid$ '')+ ') !
& 5        \\
STRING & String literal & " ([\textasciicircum{} "] $\mid$ "")* " & 0       \\
%UNOP\_POSTFIX & Unary postfix operator & \% & 0 & \% \\
%UNOP\_PREFIX & Unary prefix operator & + $\mid$ - & 0 & -                  \\
UDF & User Defined Function & (\_xll\textbackslash.)? [A-Z0-9]+  ( & 4 \\
VERTICAL-RANGE & Range of columns & \$? [A-Z]+ : \$? [A-Z]+ & 0 \\ 
\bottomrule
\end{tabular}
\end{table*}

\subsection{Lexical analysis}

Table \ref{table:tokens} contains an overview of the tokens produced by the scanner in our parser. The rules are given in a very simple regular expression language, but could be easily adapted for a scanner which does not support regular expression tokens. 
All tokens are case-insensitive. 

Our tokens also require the scanner to support token priorities. Removing the necessity for token priorities is possible by altering the tokens and production rules, but makes the grammar more complicated and the resulting tree harder to use, thus being detrimental to design goals 2 and 3.
Leaving the tokens as-is but not providing priorities will still result in an usable grammar, but expect errors on edge cases.

Some simple tokens are directly defined in the production rules in Figure \ref{figure:productions} in between quotes for readability and compactness.

\subsubsection{\textbf{Dates}}

In Excel the user can enter date and time values in a cell.
These are internally stored as positive floating point numbers with the integer portion representing the number of days since a Jan 0 1900 epoch and the fractional portion representing the portion of the day passed.
Users see either the number or the date depending on presentation settings of the cell.

This grammar only parses numeric dates and times and these are not distinguishable from other numbers.

\subsubsection{\textbf{External References}}

External references in formulas, both to external files and DDE, are not stored as part of the formula in the Microsoft Excel storage format, but instead are replaced by a numeric index.
This index is then stored in a file level dictionary of external references.
A formula that is presented to the user as \texttt{=[C:\textbackslash Path\textbackslash Filename.xlxs]Sheetname!A1} is internally stored as \texttt{[X]Sheetname!A1}, where \texttt{X} can be any number.

For this reason the presented grammar supports only numeric external references.
Adding support for full filenames can be achieved by introducing an additional token or altering the \texttt{FILE} token, but be aware that external filenames can be presented to and entered by the user in a myriad of different formats, depending on conditions such as if the file is opened in the spreadsheet program.



\begin{figure}
\caption{Production rules}
\label{figure:productions}
\centering
\begin{grammar}
<Start> ::= <Constant>
	\alt '=' <Formula>
	\alt <ArrayFormula>
	
<ArrayFormula> ::= `\{=' <Formula> `\}'

<Formula> ::= <Constant>
         \alt <Reference>
         \alt <FunctionCall>
         \alt `(' <Formula> `)'
         \alt <ConstantArray>
         \alt "RESERVED-NAME"
         
<Constant> ::= "NUMBER" | "STRING" | "BOOL" | "ERROR"
%         \alt "STRING"
%         \alt "BOOL"
%         \alt "ERROR"
         
<FunctionCall> ::= <Function> <Arguments> `)'
		\alt <UnOpPrefix> <Formula>
		\alt <Formula> `\%'
		\alt <Formula> <BinOp> <Formula>
		
<UnOpPrefix> = `+' | `-'

<BinOp> = `+' | `-' | `*' | `/' | `\textasciicircum'
	\alt `<' | `>' | `=' | `<=' | `>=' | `<>'

<Function> ::= "FUNCTION" | "UDF"
	
<Arguments> ::= <Argument>
	\alt <Argument> `,' <Arguments>

<Argument> ::= <Formula> | $\epsilon$

<Reference> ::= <ReferenceItem>
	\alt <Reference> `:' <Reference>
	\alt <Reference> `\ ' <Reference>
	\alt `(' <Union> `)'
	\alt `(' <Reference> `)' 
	\alt <Prefix> <ReferenceItem>
    \alt <Prefix> "UDF" <Arguments> `)'
    \alt <DynamicDataExchange>
    
<ReferenceItem> ::= "CELL"
	\alt <NamedRange>
	\alt "REFERENCE-FUNCTION" Arguments `)'
	\alt "VERTICAL-RANGE"
	\alt "HORIZONTAL-RANGE"
	\alt "ERROR-REF"
	
<Prefix> ::= "SHEET"
	\alt "FILE" "SHEET"
	\alt "FILE" `!'
	\alt "QUOTED-FILE-SHEET"
	\alt "MULTIPLE-SHEETS"
	\alt "FILE" "MULTIPLE-SHEETS"
	
<NamedRange> ::= "NAMED-RANGE"
            \alt "NAMED-RANGE-PREFIXED"

<Union> ::= <Reference> | <Reference> `,' <Union>
	
<DynamicDataExchange> ::= "FILE" `!' "DDECALL"

<ConstantArray> ::= `\{' <ArrayColumns> `\}'

<ArrayColumns> ::= <ArrayRows>
	\alt <ArrayRows> `;' <ArrayColumns>

<ArrayRows> ::= <ArrayConstant>
	\alt <ArrayConstant> `,' <ArrayRows>
	
<ArrayConstant> ::= <Constant>
	\alt <UnOpPrefix> "NUMBER"
	\alt "ERROR-REF"

\end{grammar}
\end{figure}

\begin{figure}
	\caption{Syntax diagram of the \synt{Formula} production rule with nonterminals exanded.}
	\label{figure:Formula}
\begin{grammar}
	<Formula> ::= \[[
	\begin{stack} 
	\begin{stack}
	\begin{stack} "FUNCTION" \\ "UDF" \end{stack} \begin{rep} \begin{stack} \\ <Formula> \end{stack} \\  '$,$' \end{rep} '$)$' \\
	\begin{stack} \\ '$+$' \\ '$-$' \end{stack} <Formula> \begin{stack} \\ '$\%$' \end{stack}\\ 
	<Formula>  \begin{stack} '$+$' \\ '$-$' \\ '$*$' \\ '$/$' \\ '\textasciicircum'  \\ '\textless' \\ '\textgreater' \\ '$=$' \\ '$\textless=$' \\ '$\textgreater=$' \\ '$\textless\textgreater$'   \end{stack} <Formula>
	\end{stack} \\
	\begin{stack} "NUMBER" \\ "STRING" \\ "BOOL" \\ "ERROR"  \end{stack} \\ "RESERVED-NAME" \\ <Reference> \\ '$($' <Formula> '$)$' \\  '$\{$' \begin{rep} \begin{rep}	\begin{stack} \begin{stack} \begin{stack} \\ '$+$' \\ '$-$' \end{stack} "NUMBER" \\ "STRING" \\ "BOOL" \\ "ERROR"  \end{stack} \\ "ERROR-REF" \end{stack} \\  '$,$' \end{rep} \\ '$;$' \end{rep} '$\}$'
	\end{stack}
	\]]
\end{grammar}
\end{figure}

\begin{figure*}
	\caption{Syntax diagram of the \synt{Reference} production rule with nonterminals expanded.}
	\label{figure:Reference}
	\centering
	\begin{grammar}
		<Reference> ::= \[[
		\begin{stack} '$($' \begin{rep} <Reference> \\  '$,$' \end{rep} '$)$'\\ <Reference> \begin{stack} '$:$' \\ '$ $' \end{stack} <Reference> \\
		\begin{stack} \\ \begin{stack} \\ "FILE" \end{stack} \begin{stack} "SHEET" \\ "MULTIPLE_SHEETS" \end{stack} \\ "FILE" '$!$' \\ "QUOTED_FILE_SHEET" \end{stack}
		\begin{stack} \begin{stack} "CELL" \\ "VERTICAL-RANGE" \\ "HORIZONTAL-RANGE" \\ \begin{stack} "NAMED-RANGE" \\ "NAMED-RANGE-COMBINED" \end{stack} \\ "ERROR-REF" \end{stack} \\  \begin{stack} "REFERENCE-FUNCTION" \\ "UDF" \end{stack} \begin{rep} \begin{stack} \\ <Formula> \end{stack} \\  '$,$' \end{rep} '$)$'\end{stack}
		\\"FILE" '$!$' "DDECALL"
		\end{stack}
		\]]
	\end{grammar}
\end{figure*}

\subsection{Syntactic analysis}
\label{subsection:productionRules}

The complete production rules of our grammar can be found in Figure \ref{figure:productions} in Extended BNF syntax.
The start symbol is $Start$.

\synt{Formula} and \synt{Reference} are the two most important production rules in this grammar.
For your convencience and understanding, these production are also available in diagram form with production rules expanded to include tokens in Figures \ref{figure:Formula} and \ref{figure:Reference}.

\begin{table}
\caption{Operator precedence in formulas}
\label{table:operatorprec}
\begin{tabular}{ll}
Precedence & Operator(s) \\
Higher is greater & \\
1 & = \textless \  \textgreater \  \textless= \  \textgreater= \  \textless\textgreater          \\
2 & \&  \\
3 & + - (binary) \\
4 & $\ast$ \\
5 & \textasciicircum \\
6 & \% \\
7 & + - (unary) \\
8 & : , \texttt{\char32}
\end{tabular}
\end{table}

\subsection{Operator Precedence}

All operators in Excel are left-associative, including the exponentiation operator which in most other languages is right-associative.
In order to resolve ambiguities a LALR parser generator needs the operator precedence to be defined, which can be found in table \ref{table:operatorprec}.

\subsection{Intersection operator}

The intersection binary operator in Excel formulas is a single space, while the rest of the language is whitespace independent outside of strings.

Our parser generator supported a feature called implicit operators which was used to implement this operator.
Implicit operators are operators which are left out and only implied, for example in calculus the multiplication operator is often omitted: $5a$ is equivalent to $5 \cdot a$.

\subsection{Ambiguity}
\label{sec:ambiguity}

Due to trade-offs on parsing references (see section \ref{tradeoff:references}) and on parsing unions (see section \ref{subsec:desing:unions}) our grammar is not fully unambiguous.
This is because of the following rules:
\begin{enumerate}
\item \begin{grammar}<Reference> ::= `(' <Reference> `)'\end{grammar}
\item \begin{grammar}<Reference> ::= `(' <Union> `)'\end{grammar}
\item \begin{grammar}<Formula> ::= `(' <Formula> `)'\end{grammar}
\end{enumerate}

A formula like \texttt{=(A1)} can be interpreted as either a bracketed reference, an union of one reference, or a reference within a bracketed formula.

In an LALR(1) parser the ambiguity manifests in a state where on a \texttt{)} token shifting on rule 1 and reducing on either rule 2 or 3 are possibilities, causing a shift-reduce conflict.
This was solved by instructing the parser generator used to shift on rule 1 in case of conflict, because this always results is a correct interpretation and thus results in a correct parse tree.

\subsection{Trade-offs}

\subsubsection{\textbf{References}}
\label{tradeoff:references}

References are of great importance in spreadsheet formulas, and thus of interest for analysis.
To support easier analysis (design goal 2) references have different production rules than other expressions.
This causes references to be easily identified and isolated, but has the downside of increasing ambiguity, see section \ref{sec:ambiguity}. 

Another approach would be to parse all formulas similarly and implement a type system, however this would be very detrimental to both ease of analysis (design goal 2) and ease of implementation (design goal 3).

\subsubsection{\textbf{Unions}}
\label{subsec:desing:unions}

As previously noted the comma serves both as an union operator and a function argument separator.
This proves challenging to correctly straightforwardly implement in a LALR(1) grammar.

A straightforward implementation would use productions similar to this:

\begin{grammar}
<Union> ::= Reference `,' Reference

<Arguments> ::= <Argument>
	\alt <Argument> `,' <Arguments>
\end{grammar}

However, this will cause a reduce-reduce conflict because the parser will have a state wherein it can reduce to both a \synt{Union} or \synt{Argument} on a \texttt{,} token.
Unfortunately there is no correct choice: in a formula like \texttt{=SUM(A1,1)} the parser must reduce on the \synt{Argument} nonterminal, while in a formula like \texttt{=A1,A1} the parser must reduce to the \synt{Union} nonterminal.
With above production rules a LALR(1) parser could not correctly parse the language.

The presented grammar only parsers unions in between brackets, e.g. \texttt{=SMALL((A1,A2),1)}.
This is a trade-off between a lower compatibility (design goal 1) and an easier implementation (design goal 3).
We deem this decreased compatibility to be acceptable since unions are very rare (see section \ref{sec:evaluation}) and all but two were within brackets (see section \ref{sec:discussion}).

Additionally formulas that this grammar now cannot parse often result in runtime errors after evaluation.
For example \texttt{=A1,A1} does parse in a spreadsheet program, but produces the error \texttt{\#VALUE!} on evaluation.

Implementing the straightforward rules above, while desirable, is not possible without using a more powerful grammar class like GLR.

\section{Evaluation}
\label{sec:evaluation}

In this Section we explain how we implemented and evaluated the grammar using the datasets, we discuss the obtained results and the formula parse failures, and then we present the grammar analysis of the datasets' formulas.

The grammar is implemented in the Irony parser generator framework\footnote{https://irony.codeplex.com/} and the resulting parser is available for download\footnote{https://github.com/PerfectXL/XLParser}.

To extract unique formulas and feed them to the parser we built a tool that opens spreadsheets using the Gembox third party library. The tool reads all cells and identifies which have the same formula in R1C1. It then selects the first cell from each group of cells that share the same formula in the R1C1 style and uses its formula string as input for the parser. It parses only one cell from each R1C1 group - the only differences between the formulas in the same group are the values of the references, so the structure of the produced parse trees is exactly the same.

To evaluate the grammar we use it to parse a total of 1,039,751 unique formulas. These originate from the two major datasets available in the spreadsheet research community: The EUSES dataset \cite{euses}, comprising of 4,498 spreadsheets and the Enron email corpus \cite{enron}, which became available after the Enron company declared bankruptcy, comprising of 16,190 spreadsheets. We were not able to process 1087 (5.25\%) of these spreadsheets, either because they are password protected or because of read failures due to the Gembox library. In total, the 19,601 spreadsheets that were processed from the two datasets include 22,632,306 formula cells. These are grouped into 1,039,751 R1C1 groups, and this is the number of unique formulas that were used as input to the parser.

To give a rough indication, processing these two datasets and extracting these results takes around 4 hours on a computer with an Intel Core i7 processor, 16GB of RAM and a Solid State Drive.

Out of the 1,039,751 unique formulas from the two datasets that were used as input to the parser, 1,039,709 (99.99\%) were parsed successfully. This satisfies our first design goal of compatibility with the official language. Regarding the second and third design goals, the implementation of the parser proved feasible and compact and the resulting parse trees suited for manipulation, having 20 types of non-terminal and 19 types of leaf nodes.

\subsection{Unparsable formulas}
The 42 formulas that were not parsed using the grammar defined in Section \ref{section:grammar} are:

\begin{itemize}
	\item \texttt{=-NOX, Regi} and \texttt{=-_SO2, Regi} in two different sheets in the Enron dataset. These are cases of an union operations not within brackets that the grammar does not parse as explained in Section \ref{subsec:desing:unions}.
	\item \texttt{=+Ë\textperthousand} was included in an Enron file that we assume to be either corrupt or another type of binary file, as the file is indecipherable.
	\item 39 formulas that are not returned correctly from the Gembox third party library that we use for opening spreadsheets. For example our tool reads and attempts to parse formula \texttt{IF(=7,AVERAGE(C4:C11),0)} and fails, but in reality the formula is \texttt{IF(B8=7,AVERAGE(C4:C11),0)} which does parse. All these 39 cases are parsed successfully when we manually provide them as input to the parser.
\end{itemize}

\subsection{Grammar Analysis}
The grammar resulted from many cycles of parse errors, enrichments and refinements. There are parts of the grammar that cover a particularly complex set of structures. In this section we analyze the formulas in the datasets and measure the frequency of their characteristics and grammatical structures. We also identify potentially smelly grammatical constructs and edge cases in the syntax of formulas.

\begin{table*}
	\label{table:occurences}
	\caption{Frequency of spreadsheet formulas with specific grammatical structures in the EUSES and Enron datasets}
	\centering
	\begin{tabular}{llrrrrr}
		\hline
		Syntax & Example &  \multicolumn{2}{c}{Unique formulas} & \multicolumn{2}{c}{Total formulas} \\
		\hline
		\synt{Formula} & \texttt{=1+2} &   \textbf{1,039,709} & & \textbf{22,630,110} & \\
		\synt{Reference} & \texttt{=E9/E10}  & 966,860 & 92.99\% & 22,451,956 & \textbf{99.21\%}\\
		CELL & \texttt{=A5}  & 955,518 & 91.90\% & 22,342,591 & 98.73\%\\
		\synt{FunctionCall} & \texttt{=SUM(A5:A22)}  & 707,783 & 68.08\% & 19,308,203 & \textbf{85.32\%}\\
		\synt{BinOp} & \texttt{=H10-H8}  & 399,046 & 38.38\% & 13,562,852 & \textbf{59.93\%}\\
		\synt{Function} & \texttt{=SUM(A5:A22)}  & 293,183 & 28.20\% & 10,569,248 & \textbf{46.70\%}\\
		FUNCTION & \texttt{=SUM(A5:A22)}  & 288,929 & 27.79\% & 10,459,005 & 46.22\%\\
		\synt{Constant} & \texttt{=SUM(A5:A22)}  & 273,310 & 26.29\% & 8,912,021 & \textbf{39.38\%}\\
		NUMBER & \texttt{=(B8/48)*15}  & 251,150 & 24.16\% & 7,966,125 &\textbf{ 35.20\%}\\
		\synt{Prefix} & \texttt{=Sheet1!B1}  & 337,917 & 32.50\% & 5,651,635 & \textbf{24.97\%}\\
		SHEET & \texttt{=Sheet1!B1}  & 304,170 & 29.26\% & 5,335,009 & 23.57\%\\
		\synt{Reference} ':' \synt{Reference} & \texttt{=SUM(A5:A22)}  & 184,877 & 17.78\% & 3,852,467 & \textbf{17.02\%}\\
		\synt{UnOpPrefix} & \texttt{=+B11+1}  & 218,527 & 21.02\% & 3,283,935 & 14.51\%\\
		STRING & \texttt{=COUNTIF(B\$4:B\$46,">=90")}  & 57,317 & 5.51\% & 2,708,039 &\textbf{11.97\%}\\
		\synt{NamedRange} & \texttt{=SUM(freq)}  & 21,240 & 2.04\% & 1,630,263 & \textbf{7.20\%}\\
		BOOL & \texttt{=IF(AND(R11=1,R14=TRUE),G19,0)}  & 7,522 & 0.72\% & 1,264,751 & 5.59\%\\
		FILE & \texttt{=[11]Sheet1!C5}  & 104,941 & 10.09\% & 1,135,234 & \textbf{5.02\%}\\
		REFERENCE-FUNCTION & \texttt{=SUM(J9:INDEX(J9:J41,B43))}  & 10,515 & 1.01\% & 780,050 &\textbf{ 3.45\%}\\
		QUOTED-FILE-SHEET & \texttt{=('[2]Detail I\&E'!D62)/1000}  & 33,782 & 3.25\% & 325,499 & 1.44\%\\
		UDF & \texttt{=SQRT(_eoq2(C5,C4,C6,C7))}  & 23,202 & 2.23\% & \textbf{303,789} & \textbf{1.34\%}\\
		'_xll.' & \texttt{=_xll.RiskTriang(F9,F7,F8)}  & 12,426 & 1.20\% & 137,886 & \textbf{0.61\%}\\
		ERROR_REF & \texttt{=AVERAGE(\#REF!)}  & 3,482 & 0.33\% & 123,476 & \textbf{0.55\%}\\
		(' \synt{Reference} ')' & \texttt{=(2*(B29))/(1+B29)}  & 5,259 & 0.51\% & 85,724 & 0.38\%\\
		VERTICAL-RANGE & \texttt{=COUNT(A:A)}  & 860 & 0.08\% & 56,118 & \textbf{0.25\%}\\
		FILE '!' & \texttt{=[1]!today}  & 2,040 & 0.20\% & \textbf{28,448} &\textbf{0.13\%}\\
		ERROR & \texttt{=IF(AND(R11=1,R14=TRUE),G19,0)}  & 380 & 0.04\% & 27,245 & \textbf{0.12\%}\\
		'\%' & \texttt{=IF(E5>I8,3\%,0\%)}  & 858 & 0.08\% & 16,606 & 0.07\%\\
			Empty argument & \texttt{=DCOUNT(Lettergrades,,I80:I81)}  & 1,343 & 0.13\% & 10,512 & \textbf{0.05\%}\\
			Complex range & \texttt{=SUM(I8:K8:M8)}  & 369 & 0.04\% & \textbf{8,583} & 0.04\%\\
			\synt{DynamicDataExchange} & \texttt{=TWINDDE|RSFRec!'NGH2 NET.CHNG''}  & 3,276 & 0.32\% & \textbf{3,686} & 0.02\%\\
			Intersection & \texttt{=Ending_Inventory Jan}  & 298 & 0.03\% & \textbf{2,829} & 0.01\%\\
			MULTIPLE-SHEETS & \texttt{=SUM(Sheet1:Sheet20!I29)}  & 173 & 0.02\% &\textbf{1,986} &\textbf{ 0.01\%}\\
			Prefixed right reference limit & \texttt{=SUM('Tot-1'!\$B8:'Tot-1'!B8)}  & 147 & 0.01\% & \textbf{1,501} & 0.01\%\\
			RESERVED_NAME & \texttt{=C23/_xlnm.Print_Area}  & 76 & 0.01\% &\textbf{1,286} & 0.01\%\\
			UDF reference & \texttt{=[1]!wbname()}  & 332 & 0.03\% & \textbf{855} & 0.00\%\\
			HORIZONTAL-RANGE & \texttt{=MATCH(F3,Prices!2:2,0)}  & 11 & 0.00\% & 836 & \textbf{0.00\%}\\
			\synt{Union} & \texttt{=LARGE((F38,C38),1)}  & 10 & 0.00\% & \textbf{385} & 0.00\%\\
			\synt{ConstantArray} & \texttt{=FVSCHEDULE(1,{0.09;0.11;0.1})}  & 15 & 0.00\% & \textbf{19} & 0.00\%\\
			\hline
	\end{tabular}
\end{table*}

\subsubsection{Formulas and Functions}

The \synt{Formula} rule covers all types of spreadsheet formula expressions. As illustrated in diagram \ref{figure:Formula}, spreadsheet formulas can be constants (\texttt{=5}), references (\texttt{=A3}), function calls (\texttt{=SUM(A1:A3)}), array constants(\texttt{=\{1,2;3,4\}}, explained in Section \ref{sec:arrayformulas}), or reserved names (\texttt{=_xlnm.Print_Area}). Function calls invoke actual named (system or user defined) functions or operators applied to one or more formulas.

Table \ref{table:occurences} shows how frequently each of the production rules in Section \ref{subsection:productionRules} occurs in the formulas of the two datasets. Jointly, 85.32\% of the formulas include a function call. Actual named functions are invoked by 46.7\% of the formulas. The vast majority are system defined functions, but there is a significant amount of formula cells (303,789 - 1.34\%) invoking user-defined functions -e.g., \texttt{=[1]!erUserEmail(User_Id)}. A special case of user defined functions are the ones created using the Excel xll add-in library. These are found in the dataset invoked as \texttt{_xll.functionName}, by 0.61\% of the formula cells.

Operators are used in 66.8\% of the formula cells, with binary operators being the most common ones, appearing in 59.93\% of the formulas. Analyzing the utilization of constants, we find that 39.38\% of the formula cells contain at least one; more than one third (35.2\%) of the formula cells contain a number and 11.97\% are formulas that contain text. Reserved names are uncommon, with 1,281 occurrences of the \texttt{_xlnm.Print_Area} and 5 occurrences of \texttt{_xlnm.Database}.

Regarding function arguments, spreadsheet systems allow empty ones (e.g. \texttt{=SUM(,E35,E37)}) but this is rarely done -in only 0.05\% of the formula cells. Unions are also rare. Only 385 formula cells contain a union used as argument, e.g. \texttt{=LARGE((F38,C38),1)}. All occurrences were arguments of the \texttt{LARGE} and \texttt{SMALL} functions -these two functions require an array of cells to be declared as a single argument, necessitating a union if the cells are not in a single range. In the EUSES dataset we also found 19 cases of constant arrays used as arguments, e.g. \texttt{=FVSCHEDULE(1,{0.09;0.11;0.1})}.

The \synt{ArrayFormula} rule, covering formulas surrounded by brackets, is the only part of the grammar that is not evaluated. The reason is that the Gembox library that we use for reading spreadsheets does not support array formulas -it reads them as regular formulas, without the surrounding brackets. For this reason, we cannot we extract information on their frequency in the two datasets.

\subsubsection{References}

Spreadsheet formulas allow for different types of references, including single cell references, cell ranges, horizontal or vertical ranges, named ranges and reference-returning build-in or user-defined functions. All of these references can be internal (in the same or in different sheets) or external. Syntactically, they can be expressed in a number of ways. The simplest case of a reference to a cell range can be expressed in any of the following ways:

\begin{eqnarray*}
	\texttt{SUM(A1:A2)} \\ 
	\texttt{= SUM(Sheet1!A1:A2)} \\
	\texttt{= SUM(Sheet1!A1:(A2))} \\
	\texttt{= SUM('Sheet1'!A1:A2)} \\
	\texttt{= SUM(Sheet1!A1:Sheet1!A2)} \\
	\texttt{= SUM(Sheet1!A1:'Sheet1'!A2)} \\
\end{eqnarray*}

The \synt{Reference} rule, drawn in diagram \ref{figure:Reference}, covers all types of referencing expressions. It was the rule that was the most complex to devise to cover all cases found in the two datasets.

As shown in Table \ref{table:occurences}, 99.21\% of the formulas in the two datasets contain at least one \synt{Reference}, and 24.97\% of the formulas contain a reference that is not local, since it includes a \synt{Prefix}. External file references exist in almost 5.02\% of the formulas. 17.02\% of the formulas include a reference with a simple (\texttt{':'} separated) cell range. Named ranges exist in 7.2\% of formulas and, interestingly, horizontal and vertical ranges are rarely used (jointly, in 0.25\% of the formulas). 0.55\% of formulas include references to errors, e.g. \texttt{=\#REF!E3}. These referencing errors are more than four times more common than all other types of errors combined -the \texttt{ERROR} token exists in 0.12\% of the formula cells.

Moving to the edge cases of the grammar, the structures that were less common in the datasets include:

\begin{description}
	\item[File-only external references] \hfill \\
	External references are normally in the form \texttt{[File]Sheet!Cell}. In 28,488 formula cells (0.13\%), however, the sheet is not specified, e.g. \texttt{=[2]!LastTrade}. These are either cases of references to external named ranges or to external UDFs.
	\item[Multiple sheet references] \hfill \\
	1,986 cells (0.01\%) contain this complex case of reference, which spans across multiple sheets. An example formula is \texttt{=SUM(Sheet1:Sheet10!A5)}, evaluated by summing all cells in position \texttt{A5} from \texttt{Sheet1} to \texttt{Sheet10}.
	\item[References to external UDFs] \hfill \\
	855 cells contain references to external user-defined functions, for example \texttt{=[1]!SheetName()}.
	\item[Prefixed right limits] \hfill \\
	1,501 cells include a reference with a prefix in the right limit, e.g. \texttt{=SUM(Deals!F9:'Deals'!F16)}. In all cases this prefix is identical to the first one, as continuous ranges spanning across multiple sheets are not supported by Excel. Still, this syntax is supported.
\end{description}

A special uncommon case in the grammar are the functions that return references, namely the \texttt{INDEX}, the \texttt{OFFSET} and the \texttt{INDIRECT} functions. For example, \texttt{INDEX} returns the reference of the cell at the intersection of a particular row and, optionally, column, so \texttt{INDEX(B1:B10,3)} returns a reference to cell \texttt{B3} and can be used in a formula as \texttt{=SUM(A1:INDEX(B1:B10,3))} being equivalent to \texttt{=SUM(A1:B3)}. These functions are relatively common: they are found in 3.45\% of the formula cells, with the most common one being the \texttt{INDEX} (in 2.47\% of formula cells) and the least common one being the \texttt{INDIRECT} (in 0.21\%). In addition to these three functions, the official formula language specification includes the \texttt{IF} and \texttt{CHOOSE} functions as able to return references, but there was no formula in the datasets using them as such.

Finally, DDE links, discussed in Section \ref{subsection:ExternalRefsDDE}, were found in 3,686 formula cells. Example formulas in the dataset include \texttt{=TWINDDE|RSFRecord!'NGH2 NET.CHNG'} and \texttt{=GLDDEML|Action!'SGIMP,LA'/100}.

\subsubsection{Smelly grammar constructs}
Having analyzed extensively the grammar of spreadsheets, there are two constructs that we consider to be smelly, i.e. counterintuitive, inconsistent to the rest of the grammar and error-prone: Complex ranges and the implicit intersect operator.

By \textit{complex ranges} we mean \synt{Reference}s that include more than two or different types of \texttt{':'} separated \synt{ReferenceItem}s. For example, range \texttt{B2:D4:C1}. Their smelly aspect is their evaluation. Normal cell ranges are in the form \texttt{top-left:bottom-right}, including all cells in between the two limits. However, the limits in complex ranges are not the ones specified in the formula: they are calculated as the upper leftmost and lower rightmost cell in the square that includes all defined cells. In the \texttt{B2:D4:C1} example, cell \texttt{B1} is also included in the range. Understanding the limits of the range becomes even less intuitive when named ranges and vertical or horizontal ranges are added. Moreover, this syntax does not add to expressiveness of the grammar: each range is still calculated as the cells within a single square, but without clearly user-defined limits. The analysis showed that complex ranges are rare: 8,583 formula cells	(0.04\%) include complex ranges in the Enron dataset, and they are all defined using three cell locations. 

The \textit{intersect operator} is included in this discussion because it is not declared as an operator. Intersection between two ranges in the grammar is represented in the most implicit way possible: by \texttt{\char32}, a single whitespace. For example, \texttt{A1:A10\char32A1:A5} is equivalent to \texttt{A1:A5}. Using this syntax, intersection is an implicit range formation operation, belonging to the \synt{Reference} rule, rather than a normal operation declared as a the \synt{Function}. An advantage of this approach is that it enables more natural language definition of intersections, e.g. \texttt{=SUM((Total_Cost Jan):(Total_Cost Apr.))}. An alternative, in our opinion less error-prone definition of intersection, would be a dedicated build-in function used explicitly as \texttt{INTERSECT(A1:A10,A1:A5)}. In the two datasets, intersection operations are not common, as they are found in only 2,829 cases of formula cells.

\section{Discussion and Limitations}
\label{sec:discussion}
The currently defined Excel grammar is able to parse 99,99\% of all formulas from two large and well-known spreadsheet datasets. In this section, we discuss a variety of issues that affect the applicability and suitability of our approach.

\subsection{Version-dependent grammar features}
The grammar had been designed as a generic spreadsheet formula grammar, enriched to include all syntactical features found in the two datasets. Both datasets, however, contain spreadsheets created by -or converted to- Excel format. This limits the grammar support for features that are spreadsheet system-dependent or even version-dependent. The built-in functions list, for example, might change across versions, which would make the parser mistakenly recognize build-in as user-defined functions.

Syntactical features can also be deprecated. An example is regular expressions in formulas. Excel allows defining formulas that include regular expressions, for example \texttt{=SUM('S*'!A1)} or \texttt{=SUM('Sheet?'!A1)}. However, in Excel 2010 and up, regular expressions are instantly resolved -in the example, to the multiple sheet reference \texttt{=SUM(Sheet2:Sheet3!A1)}, summing up all \texttt{A1} cells between \texttt{Sheet2} and \texttt{Sheet3}, where the sheets are all matching sheets, except the one that this formula is on. This way, in latest versions of Excel, saved spreadsheets never contain regular expressions.

The use of labels in formulas (a.k.a. natural language formulas) is another feature that was discontinued in Excel 2007. Labels were the headings that were typed above rows and columns, and they could be used in formulas instead of defined names or cell ranges. For example, formula \texttt{=Product A First Quarter} would return the intersection between the cell range with heading \texttt{Product A} and the one with heading \texttt{=First Quarter}. This feature is replaced in newer versions of Excel with the less error-prone named ranges feature. The proposed grammar does not support it, and it would mistakenly parse the labels as named ranges.

\subsection{Internationalization}

Excel formulas differ depending on the language of the software. For example function arguments are separated by a semicolon instead of a comma in locales that use the comma as a decimal separator. Our grammar is only for the default (English) locale. Grammars for other locales can be gotten by replacing delimiters, error values and function names by their localized versions.

It is worth noting that Excel will always save formulas in either a locale-independent binary format (Excel 2003 and earlier format) or in its English version (Excel 2007 and later format). When interacting with Excel through its API two versions of the formula can be read or written: the English version and the version in the current locale.
This makes a grammar for the English version quite useful, since the parser can eventually process all spreadsheets as long as their formulas are read using the English locale.

\subsection{Rejection of invalid formulas}

As stated in the design goals in Section \ref{sec:designgoals} the goal of this grammar is to facilitate analysis of formulas, which means correctly parsing valid spreadsheet formulas.
Rejecting invalid formulas is not among the primary goals of this grammar, as one will normally not encounter invalid formulas in Excel files.
Furthermore, while there exist two extensive datasets of valid formulas, to the best of our knowledge there are no such datasets of invalid formulas.
As such we expect that the presented grammar is too broad and will parse a large number of formulas which are not valid.
Using this grammar to parse possibly-invalid formulas like user-input might thus require additional safeguards.

The following is a non-exhaustive list of restrictions on the validity of formulas not encoded into the presented grammar\footnote{These restrictions are in place in the Excel 2007 and later format. The Excel 2003 and earlier format often has lower limits.}:

\begin{itemize}
	\item Functions cannot have more than 255 arguments.
	\item Function calls cannot be nested more than 64 levels deep.
	\item The row number cannot exceed 1,048,576 ($2^{20}$) and the column number cannot exceed XFD ($2^{14}$).
	\item A formula cannot be longer than 8,192 ($2^{13}$) characters.
\end{itemize}

\section{Related work}
\label{section:relatedWork}
Most related to our research is the work of Badame and Dig~\cite{badame2012refactoring} who, as part of their proposed spreadsheet refactoring approach, presented a grammar for spreadsheet formulas. However, they do not evaluate their grammar, and upon inspection one can see that key ingredients are missing: e.g. external references, intersections and unions and named ranges. An extension of the same grammar was used to refactor formulas by Hermans and Dig \cite{hermans2014bumblebee}.

%There have been related efforts, in which a preliminary grammar was tested on large code bases in order to extend and refine it (TODO David: PHP FB story)

As explained in the introduction, there is a large body of related work that relies on parsing spreadsheet formulas in order to analyze spreadsheets. This includes our own worl in which we have worked on an algorithm to visualize spreadsheets as dataflow diagrams\cite{DBLP:conf/icse/HermansPD11}, and subsequently on detecting smells in spreadsheets \cite{DBLP:conf/icse/HermansPD12,DBLP:conf/icsm/Hermans212}. Related approaches exist, for example the work of Cunha that have worked on code smells~\cite{iccsa12} and smell-based fault localization~\cite{conf/icsme/CunhaFMPS14}. These papers too analyze spreadsheet formulas but do not detail whether they use a grammar or what alternative they use.

\section{Conclusion}
\label{section:conclusion}

In this paper we present a grammar for spreadsheet formulas that we evaluated against over one million unique formulas and that successfully parses 99.99\%, covering a particularly complex set of structures. The grammar was used to analyze the formulas in the datasets and to measure the frequency of their characteristics and grammatical structures. We found uncommon cases in the syntax of formulas, and we identified complex ranges and the implicit intersect operator as potentially smelly grammatical constructs.

The grammar is compact, consisting of 20 production rules and producing processable parse trees, suited for further manipulation and analysis. We believe that the grammar is reliable and concise enough to facilitate further research on spreadsheet formula code bases. It has already been applied in other works for analyzing formula characteristics, calculation chains and code smells and for applying formula transformations. The grammar parser is available as open-source software.

\section{Future Work}

A weak point of the presented grammar is that the full extend of compatibility with the official Microsoft Excel Grammar is unknown.
An improvement could be made to this grammar by comparing it to the official specification, either by improving compatibility or by extending the number of known limitations.
In general the problem of determining whether two Context-free grammars are equivalent is undecidable, but in practice several techniques have been successfully used for this purpose.


\bibliographystyle{IEEEtran}
\bibliography{XLGrammarRefs}

\end{document}


