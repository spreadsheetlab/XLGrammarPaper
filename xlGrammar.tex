
\documentclass[conference]{IEEEtran}

%\usepackage{cite}

% correct bad hyphenation here
\hyphenation{}

\usepackage{eurosym}
\usepackage{amsfonts}
\usepackage{cite}

%\usepackage{appendix}

% Tables
\usepackage[table,xcdraw]{xcolor}
\usepackage{booktabs}
\usepackage{pbox}
\renewcommand{\arraystretch}{1.2} 
%\renewcommand*\cmidrule{} % No table middle lines
%\renewcommand{\arraystretch}{1.5} % Additional spacing with no middle lines
%\renewcommand*\cmidrule{\hdashline[1pt/2pt]}% Dashed middle lines
\renewcommand*\cmidrule{\midrule[0.001em]} % Thin table middle lines
%\renewcommand*\cmidrule{\midrule} % Thick table middle lines

%Images
\usepackage[pdftex]{graphicx}
\graphicspath{ {}{img/} }
\DeclareGraphicsExtensions{.pdf,.jpg,.png}

% Syntax package configuration
\usepackage[rounded]{syntax}
\setlength{\grammarparsep}{4pt plus 1pt minus 1pt}

\newcommand{\todo}[1]{\textbf{TODO: #1}}
\newcommand{\ignore}[1]{}

\begin{document}
\title{A LALR(1) Grammar for Spreadsheet Formulas Evaluated in Two Large Datasets}

\author{\IEEEauthorblockN{Efthimia Aivaloglou, David Hoepelman, Felienne Hermans}
	\IEEEauthorblockA{Software Engineering Research Group\\
		Delft University of Technology\\
		Mekelweg 4, 2628 CD Delft, the Netherlands\\
		e.aivaloglou@tudelft.nl, dhoepelman@gmail.com, f.f.j.hermans@tudelft.nl}
}
\maketitle

\begin{abstract}
Spreadsheets are ubiquitous in the industrial world and often perform a role similar to other computer programs in many different domains.
However, there exists no reliable grammar that is concise enough to facilitate research on spreadsheet formula code bases.
This paper presents a grammar for spreadsheet formulas that is compatible, is compact enough to feasibly implement with a parser generator, and produces parse trees suited for further manipulation and analysis. 
This grammar is then evaluated against more than one million unique formulas extracted from the EUSES and Enron spreadsheet datasets, successfully parsing 99.99\%.
Additionally, we utilize the grammar to analyze the the formulas in these datasets and measure the frequency of utilization of language features in spreadsheet formulas.
Finally, we identify smelly constructs and edge cases in the syntax of formulas.
\end{abstract}

\IEEEpeerreviewmaketitle


\section{Introduction}

spreadsheets as programming:
- cell calculation chains as lines of code - size, example
- avg lines of code per spreadsheet in the enron dataset

motivation: why we need a defined grammar
- parsing spreadsheet formulas, analysis, extracting metrics, finding smells, exploring the structure of spreadsheets
- refer to papers needing/referring to a simple grammar
- benefit of a simple grammar and documentation for spreadsheet users
- to explore/uncover smelly syntactical constructs that are within the grammar coverage

challenges:
- official grammar for Excel defined, but too complex/implementation specific for formula analysis
- excel is very forgiving
- grammar changes with different Excel versions, eg regular expressions support, labels in formulas now expanded to cell
references, updates in the built-in functions list

our approach:
development of grammar starting from previous work (reference to simple grammar) and analyzing the two datasets, enriching the
grammar to support everything
(The grammar resulted from many cycles of parse errors, enrichments and refinements. There are parts of the grammar that cover a particularly complex set of structures)

contributions:
- grammar
- evaluation of the grammar on the datasets
- datasets analysis: formula characteristics

\section{Anatomy of Excel Spreadsheets and Formulas}

Microsoft Excel is a program which allows its users to create spreadsheets.
Spreadsheets are cell-oriented dataflow programs and Excel spreadsheets are Turing complete \cite{ExcelTuringComplete}.

A single spreadsheet \emph{file} corresponds to a single (\emph{work})\emph{book}.
A workbook can contain any number of (\emph{work})\emph{sheets}.
A sheet consists of a two-dimensional grid of \emph{cells}.
The table consists or verticals \emph{rows} and horizontal \emph{columns}.
Rows are numbered sequentially top-to-bottom starting at 1, while columns are numbered left-to-right alphabetically, i.e. base-26 using A to Z as digits, starting at `A', making column 27 `AA'.

A cell can be empty or contain a \emph{constant value}, \emph{formula} or \emph{array formula}.
A formula can contain constant values, operations such as multiplication with the \texttt{*} operator and \emph{function calls} such as \texttt{SUM(\ldots)}, and most importantly \emph{references} to other cells.
Function arguments are separated by a comma.

Formulas can also work with \emph{ranges}, which are a two-dimensional matrices of cells.
Ranges can be constructed by the range operator \texttt{:} which produces a rectangular range with the two arguments as topmost left an bottommost right corners, the union operator \texttt{,} (a comma) \footnote{This is not a mathematical union as duplicates are allowed.} or the intersection operator \texttt{\char32} (a single whitespace). 
An user can also give a name to any range of cells thus creating a \emph{named range} which can be referenced in formulas by name.

\subsection{References}
The references are arguably the most important part of spreadsheets.
The value of any cell can be used in a formula by concatenating its column and row number, producing a reference like \texttt{B5}.
If a value of a cell changes this new value will be propagated to all formulas that use it.

When copying a cell to another cell by default references will be adjusted by the offset, for example copying \texttt{=A1} from cell B1 to C2 will cause the copied formula to become \texttt{=B2}.
This can be prevented by making the reference absolute by prepending a \texttt{\$} to the column index, row index or both.
The formula \texttt{=\$A\$1} will remain the same on copy while \texttt{=\$A1} will still have its row number adjusted.

An alternate style called R1C1 as opposed to the above A1 style exists, but it is very rarely seen or used by users.
In R1C1 references you specify either the offset to a cell between square brackets or its concrete location.
In R1C1 style \texttt{R[4]C[-2]} means the cell two columns to the left and four rows down, \texttt{R2C2} refers to cell B2.
The biggest advantage of R1C1 is that it causes identical formulas to be the same even when they operate on different cells or data because of their position.
These properties might make R1C1 useful as an internal representation for your intended purpose, but this grammar does not support parsing it.



\subsection{Sheet and external references and DDE}

By default references are to cells or ranges in the same sheet as the formula, but this can be modified with a prefix. A prefix consists of some identifier, followed by an exclamation mark followed by the actual reference.

The most common use case is to reference another sheet in the same workbook, where the prefix is simply the sheetname: \texttt{=Sheetname!A1}. References to external spreadsheet files are also possible, which is done by prepending the file name in between square brackets like \texttt{=[Filename]Sheetname!A1} or \texttt{=[Filename]!NamedRange}. A peculiar type of prefix are those that indicate multiple sheets

Formulas can also call external programs through the Windows-specific Dynamic Data Exchange (DDE).
These formula's take the form of \texttt{=Program|Topic!Arguments}.

\subsection{Array Formulas and Arrays}

Excel provides some limited functionality to work with one- or two-dimensional matrices. The most common ones are the perviously mentioned ranges, which directly correspond to portions of the spreadsheet.

It is also possible to construct matrices from constant values, which excel calls \emph{Array constants}.
Arrays are surrounded by curly brackets, columns are separated by commas, and rows by semicolons.
As an example \texttt{\{1,2,3;4,5,6\}} constructs an array of 2 rows high and 3 columns wide.

\emph{Array Formulas} use the same syntax as normal formulas, except the use must enter \emph{Ctrl} + \emph{Shift} + \emph{Enter} to signal to Excel that it is an Array formula. Excel surround the formula with curly braces. Array Formulas allow the user to work less restrained with arrays in a formula and allow the user to return multiple results, which will be presented in multiple cells.


\section{Design Decisions}
For previous and ongoing research the authors needed a grammar for Microsoft Excel formulas with the following requirements:

\begin{enumerate}
\item Be as compatible as possible
\item Produce a parse tree suited for further manipulation and analysis with minimal post-processing required
\item Be compact enough to feasibly implement with a parser generator
\end{enumerate}

Microsoft has published an official grammar for Excel formulas \todo{cite}.
However, this grammar is over 30 pages long and thus fails requirement 3.
Furthermore because of the detail of the grammar and the large number of production rules the resulting parse tree fails requirement 2.

For this reason the authors decided to construct their own grammar based with the above requirements as design goals.

\subsection{Grammar class}

The class of this grammar is LALR(1), which was motivated by the available tool support and relative few restrictions as opposed to LL(1) or recursive-dependent parsers, which supports design goals 2 and 3.
Generalized LR grammar parser generators provide more freedom, but were not chosen because of lack of suitable tools for our target environment.

\subsection{References}
\label{subsec:design:references}

\todo{Can you check if this is clear enough and not damaging the paper?}

References are of great importance in spreadsheet formulas, and thus of interest for analysis.
To support design goal 2 references have different nonterminals than other expressions.
This is possible because operators working with references have the highest precedence of all, but is not perfect due to User Defined Functions of which the type is unknown.
However, User Defined Functions are very rare as can be seen in section \ref{sec:evaluation}.

Another approach would be to parse all formulas similarly and implement a type system, however this would be very detrimental to both design goal 2 an 3.

\subsection{Unions}
\label{subsec:desing:unions}

As previously noted the comma serves as both a union operator and a function argument separator.
This proved challenging to correctly straightforwardly implement in a LALR(1) grammar.

A straightforward implementation would use productions similar to this:

\begin{grammar}
<Union> := Reference `,' Reference

<Arguments> := <Argument> | <Argument> `,' <Arguments>
\end{grammar}

This however will cause a reduce reduce conflict, because in a formula like \texttt{=SUM(A1,1)} the parser does not have enough information to decide to reduce to a \synt{Union} or \synt{Argument} at the \texttt{,} token.

The presented grammar only parsers unions in between brackets, e.g. \texttt{=SMALL((A1,A2),1)}.
This is a trade-off between our compatibility (lower) and the compactness of the grammar (better).
We deem this decreased compatibility to be acceptable since unions are very rare and all but two were within brackets, see section \ref{sec:discussion}.
Furthermore formulas that this grammar now cannot parse often result in runtime errors after evaluation anyway, for example \texttt{=A1,A1} does parse in Excel, but produces the error \texttt{\#VALUE!}.

If your implementation can support the more straightforward definition we recommend altering the grammar on this point.

\subsection{External References}

External references in formulas, both to external files and DDE, are not stored as part of the formula in the Excel storage format, but instead are replaced by a numeric index.
A formula that is presented to the user as \texttt{=[C:\textbackslash Path\textbackslash Filename.xlxs]Sheetname!A1} is internally stored as \texttt{[1]Sheetname!A1}.

For this reason this grammar supports only numeric external references.
Adding support for full filenames can be achieved by introducing an iditional token or altering the \texttt{FILE} token, but be aware that external filenames can be presented to and entered by the user in a myriad of different formats, depending on conditions such as if the file is opened in Excel.

\section{Spreadsheet Formula Grammar}
\label{section:grammar}

\todo{Add appendix with excel function names}

All strings and characters are case-insensitive, unless otherwise noted.

\subsection{Lexical analysis}

Table \ref{table:tokens} contains an overview of the tokens produced by the scanner in our parser. The rules are given in a very simple regular expression language, but could be easily adapted for a scanner which does not support regular expression tokens. 

Our tokens also require the scanner to support token priorities. Removing the necessity for token priorities is possible by altering the tokens and production rules, but makes the grammar more complicated and the resulting tree harder to use. Leaving the tokens as-is but not providing priorities will still result in an usable grammar, but expect errors on edge cases.

\begin{table*}
\label{table:tokens}
\caption{Lexical tokens used in our grammar}
\begin{tabular}{@{}lllll@{}}
\toprule
Token Name & Description & Regular Expression & Priority & Example \\
\midrule
BINOP & Binary Operator & + $\mid$ - $\mid$ / $\mid$ * $\mid$ \textasciicircum $\mid$ \textless $\mid$ \textgreater $\mid$ = $\mid$ \textless= $\mid$ \textgreater= $\mid$ \textless \textgreater & 0 & + \\
BOOL & Boolean literal & TRUE $\mid$ FALSE & 0 & TRUE \\
CELL & Cell reference & \$? [A-Z]+ \$? [0-9]+ & 2 & $A$1 \\
DDECALL & Dynamic Data Exchange & ' ([A-Z0-9\_ !@\#\$\%\textasciicircum{}\&*()\-+=\{\}:;$\mid$\textless\textgreater,./?\textbackslash{}\textbackslash{}] $\mid$ '')+ ' & 0 & \texttt{`NGK1,PRIM ACT 1'}\\
ERROR & Error literal & \#NULL! $\mid$ \#DIV/0! $\mid$ \#VALUE! $\mid$   \#REF! $\mid$ \#NAME? $\mid$ \#NUM! $\mid$ \#N/A & 0 & \#REF! \\
FILE & External file reference & \textbackslash[ [0-9]+ \textbackslash] & 5 & [1]\\
FUNCTION & Excel built-in function & (Any entry from Appendix X) \textbackslash( & 5        & SUM( \\
HORIZONTAL\_RANGE & Range of rows & \$? [0-9]+ : \$? [0-9]+ & 0 & 1:4 \\
MULTIPLE\_SHEETS & Multiple sheet references &
[A-Z0-9]+ : ([A-Z0-9\_.]+ $\mid$ ' ([A-Z0-9\_ !@\#\$\%\textasciicircum{}\&*()\-+=\{\}:;$\mid$\textless\textgreater,./?\textbackslash{}\textbackslash{}] $\mid$ '')+  ') !
& 1 & Sheet1:'Escape '' 5'! \\
NAMED\_RANGE & Named range & [A-Z\_][A-Z0-9\_.]* & -2 & MYNAME \\
NAMED\_RANGE\_PREFIXED & \begin{tabular}[c]{@{}l@{}} Named range which starts with \\ a string  that could be another token \end{tabular} & (TRUE $\mid$ FALSE $\mid$ [A-Z]+[0-9]+)    {[}A-Z0-9\_.{]}+                                                                             & 3 & A1MYNAME \\
NUMBER\_LITERAL & \begin{tabular}[c]{@{}l@{}}An integer, floating point\\     or scientific notation number literal\end{tabular} & (+ $\mid$ -)? [0-9]+ ,? [0-9]* (e [0-9]+)? & 0 & 10.1e12 \\
QUOTED\_FILE\_SHEET & A file reference within single quotes & '\textbackslash[ [0-9]+ \textbackslash] ([0-9A-Z\_ !@\#\$\%\textasciicircum{}\&*()\-+=\{\}:;$\mid$\textless\textgreater,./?\textbackslash{}\textbackslash{}] $\mid$ '')+ '!
& 5        & '{[}1{]}My Sheet'! \\
REFERENCE\_FUNCTION & Excel built-in reference function & (INDEX $\mid$ OFFSET $\mid$ INDIRECT)\textbackslash( & 5 & INDEX( \\
RESERVED\_NAME & An Excel reserved name & \_xlnm\textbackslash.  [A-Z\_]+ & -1 & \_xlnm.History \\
SHEET & The name of a worksheet &
	([0-9A-Z\_.]+ $\mid$ ' ([0-9A-Z\_ !@\#\$\%\textasciicircum{}\&*()\-+={}$\mid$:;\textless\textgreater,./?\textbackslash\textbackslash] $\mid$ '')+ ') !
& 5        & Sheet1!            \\
STRING & String literal & " ([\textasciicircum{} "] $\mid$ "")* " & 0        & "He Said: ""Hi"""  \\
UNOP\_POSTFIX & Unary postfix operator & \% & 0 & \% \\
UNOP\_PREFIX & Unary prefix operator & + $\mid$ - & 0 & -                  \\
UDF & User Defined Function & (\_xll\textbackslash.)? [A-Z0-9]+  ( & 4 & MyFunction( \\
VERTICAL\_RANGE & Range of columns & \$? [A-Z]+ : \$? [A-Z]+ & 0 & A:Z \\ 
\bottomrule
\end{tabular}
\end{table*}

\subsection{Syntactic analysis}
\label{section:productionRules}

We define our production rules in Extended BNF syntax. The start symbol is $Start$. If one does not wish to accept array formula's and wishes to omit the `=' at the start of a formula $Formula$ can be used as a start symbol instead, or the $Start$ non-terminal can be adjusted.

\begin{grammar}
<Start> ::= <Constant>
	\alt '=' <Formula>
	\alt <ArrayFormula>
	
<ArrayFormula> ::= `\{=' <Formula> `\}'

<Formula> ::= <Constant>
         \alt <Reference>
         \alt <FunctionCall>
         \alt `(' <Formula> `)'
         \alt <ConstantArray>
         \alt "RESERVED_NAME"
         
<Constant> ::= "NUMBER"
         \alt "STRING"
         \alt "BOOL"
         \alt "ERROR"
         
<FunctionCall> ::= <Function> <Arguments> `)'
		\alt "UNOP_PREFIX" <Formula>
		\alt <Formula> "UNOP_POSTFIX"
		\alt <Formula> "BINOP" <Formula>

<Function> ::= "FUNCTION"
	\alt "UDF"
	
<Arguments> ::= <Argument>
	\alt <Argument> `,' <Arguments>

<Argument> ::= Formula | $\epsilon$

%<Error> ::= "ERROR"
%
%<String> ::= "STRING"
%
%<QuotedFileSheet> ::= "QUOTED_FILESHEET"
%
%<Sheet> ::= "SHEET"
%
%<MultipleSheets> ::= "MULTIPLE_SHEETS"


%<File> ::= "FILE"


<Reference> ::= <ReferenceItem>
	\alt <Reference> `:' <Reference>
	\alt <Reference> `\ ' <Reference>
	\alt `(' <Union> `)'
	\alt `(' <Reference> `)' 
	\alt <Prefix> <ReferenceItem>
    \alt <Prefix> "UDF" <Arguments> `)'
    \alt <DynamicDataExchange>
    
<ReferenceItem> ::= "CELL"
	\alt <NamedRange>
	\alt "REFERENCE_FUNCTION" Arguments `)'
	\alt "VERTICAL_RANGE"
	\alt "HORIZONTAL_RANGE"
	\alt "ERROR"
	
<Prefix> ::= "SHEET"
	\alt "FILE" "SHEET"
	\alt "FILE" `!'
	\alt "QUOTED_FILE_SHEET"
	\alt "MULTIPLE_SHEETS"
	\alt "FILE" "MULTIPLE_SHEETS"
	
<NamedRange> ::= "NAMED_RANGE"
            \alt "NAMED_RANGE_PREFIXED"

<Union> ::= <Reference>,
	\alt <Reference> `,' <Union>
	
<DynamicDataExchange> ::= "FILE" `!' "DDECALL"

<ConstantArray> ::= `\{' <ArrayColumns> `\}'

<ArrayColumns> ::= <ArrayRows>
	\alt <ArrayRows> `;' <ArrayColumns>

<ArrayRows> ::= <Constant>
	\alt <Constant> `,' <ArrayRows>

\end{grammar}

\subsection{Operator Precedence}

All operators in Excel are left-associative, including the exponentiation operator which in most other languages is right-associative.
In order to resolve ambiguities in our grammar a LALR parser generator needs the operator precedence to be defined, which can be found in Table \ref{table:operatorprec}.

Often LALR parser generators support this feature, but if you parser generator does not support operator precedence it will need to be manually encoded into the grammar.

\begin{table}
\label{table:operatorprec}
\caption{Operator precedence in Excel Formulas}
\begin{tabular}{lr}
Operator                                                                & Precedence \\
 & higher = greater \\
= \textless \  \textgreater \  \textless= \  \textgreater= \  \textless\textgreater & 1          \\
\&                                                                      & 2          \\
+ - (binary)                                                            & 3          \\
* /                                                                     & 4          \\
\textasciicircum                                                        & 5          \\
\%                                                                      & 6          \\
+ - (unary)                                                             & 7          \\
: \texttt{\char32}                                                             & 8         
\end{tabular}
\end{table}

\subsection{Ambiguity}

%Unfortunately our grammar is not fully unambiguous, the root cause being the design decision in \ref{subsec:unionoperator}. In an LALR(1) parser generator \synt{Formula} and \synt{Union} cause a reduce-reduce conflict because a formula like \texttt{=(A1)} can be interpreted as both an union of one reference and a bracketed reference.
%Instruct your parser generator to choose the \synt{Formula} production to resolve this conflict.

Unfortunately our grammar is not fully unambiguous, the root causes being the design decisions on parsing references in section \ref{subsec:design:references} and on parsing unions in section \ref{subsec:desing:unions}.
This is because in an LALR(1) parser generator the following rules conflict:
\begin{enumerate}
\item \begin{grammar}<Reference> ::= `(' <Reference> `)'\end{grammar}
\item \begin{grammar}<Reference> ::= `(' <Union> `)'\end{grammar}
\item \begin{grammar}<Formula> ::= `(' <Formula> `)'\end{grammar}
\end{enumerate}

This ambiguity is because a formula like \texttt{=(A1)} can be interpreted as either a bracketed reference, an union of one reference, or a reference within a bracketed formula.

In this case the problem manifests as a shift-reduce conflict between shifting on rule 1, or reducing on either rule 2 or 3.
Instruct your parser generator to shift on rule 1 because this is always a correct interpretation.

%Unfortunately our grammar is not fully unambiguous, because we made a trade-off between avoid ambiguity, simplicity of the grammar and usefulness of the resulting trees. The following ambiguities are present and must be manually resolved using the methods your parser generator provides:

%\synt{FunctionCall} and \synt{Reference} can conflict when a bracketed reference is present where any formula can be present. Either parse is correct as they are logically equivalent, but we recommend parsing this as \synt{FunctionCall}. Example ambiguous sentence: \texttt{=(A1)}.

%\todo{Remark that there does not seem a way to properly resolve. We accept this because union is very rare.}

%\todo{Formula brackets and union}

\subsection{Intersection operator}

The intersection binary operator in Excel formulas is a single space, while the rest of the language is mostly whitespace independent.
Care must thus be taken on this point when implementing this grammar.

If your parser supports implicit tokens or operators the intersection operator can be implemented this way.
An example of implicit operators outside of Excel formulas is in calculus where multiplication is often omitted and $5a$ is equivalent to $5 \cdot a$ thus making $\cdot$ an implied operator.


\section{Evaluation}

\todo{In evaluation note that we have achieved the design goals of section design decisions}

The grammar is implemented in the Irony parser generator framework\footnote{https://irony.codeplex.com/} and the resulting parser is available for download\footnote{link for download}.

To extract formulas and feed them to the parser we built a tool that opens spreadsheets using the Gembox third party library. The tool reads all cells and identifies which have the same formula in R1C1. It then selects the first cell from each sibling class (i.e., group of cells that share the same formula in the R1C1 style) and uses its formula string as input to the parser. It parses only one cell from each sibling class - the only differences between the formulas in a sibling class are the values of the references, so the structure of the produced abstract syntax trees is exactly the same. The abstract syntax trees are then traversed to generate a variety of information, for example, the references of cells to other cells, the functions that are used, the operations that are performed and the fixed numbers in the formulas.

To evaluate the grammar we use it to parse a total of 1,061,360 formulas. Those were found in the two major datasets available in the spreadsheet research community: The Euses dataset \cite{euses}, comprising of 4,498 spreadsheets and the Enron email corpus \cite{enron}, which became available after the Enron company declared bankruptcy, comprising of 16,190 spreadsheets. We were not able to process 1087 (5.25\%) of these spreadsheets, either because they are password protected or because of read failures due to the Gembox library. In total, the 19,601 spreadsheets that were processed from the two datasets include 23,559,993 formula cells. These are grouped into 1,061,360 sibling classes, and this is the number of formulas that were used as input to the parser.

Processing the two datasets and extracting those results in a standard machine with Intel Core i7 processor and 16GBs of memory takes about 4 hours.

\section{Discussion}
\label{sec:discussion}

Out of the 1,061,360 formulas from the two datasets that were used as input to the parser, 1,061,326 (99.99\%) were parsed successfully. The formulas that were not parsed using the grammar defined in Section \ref{section:grammar} are:

\begin{itemize}
	\item formulas \texttt{=-NOX, Regi} and \texttt{=-_SO2, Regi} in two different sheets in the Enron dataset. These are cases of Union operations that the grammar does not parse as explained in Section \ref{subsec:desing:unions}.
	\item formula \texttt{=+Ë‰} was included in an Enron file that we assume to be corrupt, as it only included similarly formatted characters. todo: fix formula appearance
	\item 31 cases of formulas that are not returned correctly from the Gembox third party library that we use for opening spreadsheets -e.g., our tool reads and attempts to parse formula \texttt{IF(=7,AVERAGE(C4:C11),0)} and fails, but in reality the formula is \texttt{IF(B8=7,AVERAGE(C4:C11),0)} which does parse. All these 31 cases are parsed successfully when we manually provide them as input to the parser.
\end{itemize}

\subsection{Grammar Analysis}
The grammar resulted from many cycles of parse errors, enrichments and refinements. There are parts of the grammar that cover a particularly complex set of structures. In this section we analyze the formulas in the datasets and measure the frequency of their characteristics and grammatical structures. We also identify potentially smelly grammatical constructs and edge cases in the syntax of formulas.

todo: add percentages for unique formulas, sort by frequency, change headers to euses formulas: unique and total

\begin{table*}
	\label{table:occurences}
	\caption{Frequency of spreadsheet formulas with specific grammatical structures in the Euses and Enron datasets}
	\begin{tabular}{llrrrrrrr}
		\hline
		Syntax & Example & euses &  &  & enron &  & \\
		&  & 1st sibling formulas & formula cells &  & 1st sibling formulas & formula cells & \\
		\hline
		<Formula> & \texttt{=1+2} & 95,693 & 1,459,263 &  & 965,633 & 22,099,208 & \\
		<FunctionCall> & \texttt{=SUM(A5:A22)} & 69,545 & 1,075,753 & 73.72\% & 654,943 & 18,925,707 & 85.64\%\\
		<Function> & \texttt{=SUM(A5:A22)} & 40,908 & 770,280 & 52.79\% & 264,245 & 10,329,456 & 46.74\%\\
		FUNCTION & \texttt{=SUM(A5:A22)} & 40,501 & 759,317 & 52.03\% & 258,494 & 10,199,344 & 46.15\%\\
		UDF & \texttt{=SQRT(_eoq2(C5,C4,C6,C7))} & 742 & 12,811 & 0.88\% & 24,635 & 345,405 & 1.56\%\\
		_xll. & \texttt{=_xll.RiskTriang(F9,F7,F8)} & 16 & 89 & 0.01\% & 13,005 & 170,888 & 0.77\%\\
		UNOP-PREFIX & \texttt{=+B11+1} & 7,821 & 61,903 & 4.24\% & 214,182 & 3,308,311 & 14.97\%\\
		UNOP-POSTFIX & \texttt{=IF(E5>I8,3\%,0\%)} & 215 & 1,091 & 0.07\% & 666 & 15,560 & 0.07\%\\
			BINOP & \texttt{=H10-H8} & 39,325 & 567,228 & 38.87\% & 368,020 & 13,466,887 & 60.94\%\\
			
			NUMBER & \texttt{=(B8/48)*15} & 24,989 & 341,531 & 23.40\% & 231,598 & 7,955,091 & 36.00\%\\
			STRING & \texttt{=COUNTIF(B\$4:B\$46,">=90")} & 9,402 & 156,907 & 10.75\% & 50,490 & 2,685,412 & 12.15\%\\
			BOOL & \texttt{=IF(AND(R11=1,R14=TRUE),G19,0)} & 672 & 32,802 & 2.25\% & 6,925 & 1,249,218 & 5.65\%\\
			Reserved name (_xlnm.) & \texttt{=C23/_xlnm.Print_Area} & 7 & 8 & 0.00\% & 51 & 302 & 0.00\%\\
			Empty argument & \texttt{=DCOUNT(Lettergrades,,I80:I81)} & 128 & 3,614 & 0.25\% & 1,225 & 7,138 & 0.03\%\\
			<ArrayFormula> & \texttt{=FVSCHEDULE(1,{0.09;0.11;0.1})} & 15 & 19 & 0.00\% &  &  & 0.00\%\\
			ArrayAsArgument??? & \texttt{=LARGE((F38,C38),1)} & 1 & 34 & 0.00\% & 9 & 351 & 0.00\%\\
			\hline
			<Reference> & \texttt{=E9/E10} & 86,291 & 1,443,464 & 98.92\% & 901,596 & 21,938,254 & 99.27\%\\
			<Reference> ':' <Reference> & \texttt{=SUM(A5:A22)} & 26,194 & 473,491 & 32.45\% & 164,322 & 3,584,966 & 16.22\%\\
			<Reference> ' ' <Reference> (intersection) & \texttt{=Ending_Inventory Jan} & 207 & 2,098 & 0.14\% & 197 & 348 & 0.00\%\\
			(' <Reference> ')' & \texttt{=(2*(B29))/(1+B29)} & 810 & 5,834 & 0.40\% & 4,676 & 89,886 & 0.41\%\\
			<Prefix> & \texttt{=Sheet1!B1} & 29,257 & 439,725 & 30.13\% & 313,889 & 5,458,890 & 24.70\%\\
			FILE & \texttt{=[11]Sheet1!C5} & 1,391 & 8,472 & 0.58\% & 102,449 & 1,126,446 & 5.10\%\\
			FILE '!' & \texttt{=[1]!today} & 264 & 655 & 0.04\% & 1,777 & 27,794 & 0.13\%\\
			SHEET & \texttt{=Sheet1!B1} & 28,308 & 437,110 & 29.95\% & 281,186 & 5,144,043 & 23.28\%\\
			QUOTED-FILE-SHEET & \texttt{=('[2]Detail I\&E'!D62)/1000} & 680 & 1,746 & 0.12\% & 33,006 & 324,588 & 1.47\%\\
			MULTIPLE-SHEETS & \texttt{=SUM(Sheet1:Sheet20!I29)} & 9 & 234 & 0.02\% & 164 & 1,752 & 0.01\%\\
			CELL & \texttt{=A5} & 84,929 & 1,440,266 & 98.70\% & 892,393 & 21,827,673 & 98.77\%\\
			REFERENCE-FUNCTION & \texttt{=SUM(J9:INDEX(J9:J41,B43))} & 846 & 67,072 & 4.60\% & 10,586 & 723,460 & 3.27\%\\
			VERTICAL-RANGE & \texttt{=COUNT(A:A)} & 322 & 1,805 & 0.12\% & 547 & 55,177 & 0.25\%\\
			HORIZONTAL-RANGE & \texttt{=MATCH(F3,Prices!2:2,0)} &  &  & 0.00\% & 14 & 839 & 0.00\%\\
			<NamedRange> & \texttt{=SUM(freq)} & 1,598 & 22,846 & 1.57\% & 21,112 & 1,704,791 & 7.71\%\\
			ERROR & \texttt{=AVERAGE(\#REF!)} & 683 & 20,774 & 1.42\% & 3,547 & 133,377 & 0.60\%\\
			UDF reference & \texttt{=[1]!wbname()} & 251 & 608 & 0.04\% & 81 & 247 & 0.00\%\\
			Prefixed right reference limit & \texttt{=SUM('Total-1'!\$B8:'Total-1'!B8)} & 108 & 941 & 0.06\% & 39 & 560 & 0.00\%\\
			Ranges with more than two limits & \texttt{=SUM(I8:K8:M8)} &  &  & 0.00\% & 357 & 8,566 & 0.04\%\\
			External DDE links & \texttt{=TWINDDE|RSFRecord!'NGH2 NET.CHNG''} & 121 & 254 & 0.02\% & 3,155 & 3,432 & 0.02\%\\
			\hline
	\end{tabular}
\end{table*}

\subsubsection{Formulas and Functions}

The \synt{Formula} rule covers all types of spreadsheet formula expressions. Its syntax diagram, decomposed to include terminal tokens, is illustrated below.

\begin{grammar}
	<Formula> ::= \[[
	\begin{stack} 
	\begin{stack}
	\begin{stack} "FUNCTION" \\ "UDF" \end{stack} \begin{rep} \begin{stack} \\ <Formula> \end{stack} \\  '$,$' \end{rep} '$)$' \\
	"UNOP-PREFIX" Formula\\
	Formula "UNOP-POSTFIX"\\
	Formula "BINOP" Formula
	\end{stack} \\
	\begin{stack} "NUMBER" \\ "STRING" \\ "BOOL" \\ "ERROR"  \end{stack} \\ "RESERVED-NAME" \\ <Reference> \\ '$($' <Formula> '$)$' \\  <ConstantArray???>
	\end{stack}
	\]]
\end{grammar}

According to it, spreadsheet formulas can be constants (\texttt{=5}), references (\texttt{=A3}), function calls (\texttt{=SUM(A1:A3)}), constant arrays???, or reserved names (\texttt{=_xlnm.Print_Area}). Function calls invoke actual named (system or user defined) functions or operators applied to one or more formulas. 
	
Table \ref{table:occurences} shows how frequently each of the production rules in Section \ref{section:productionRules} occurs in the formulas of the two datasets. Jointly, 85\% of the formulas include a function call. Actual named functions are invoked by 47\% of the formulas. The vast majority are system defined functions, but there is a significant amount of formula cells (358,216 - 1.5\%) invoking user-defined functions -e.g., \texttt{=[1]!erUserEmail(User_Id)}. A special case of user defined functions are the ones created using the Excel xll add-in library. Those are found in the dataset invoked as \texttt{_xll.functionName}, by 0.73\% of the formula cells.

Operators are used in 66.3\% of the formula cells, with binary (???) operators being the most common ones, appearing in 60\% of the formulas. Analyzing the utilization of constants, we find that more than one third (35.2\%) of the formula cells contain a number and 12\% are formulas that contain text. The reserved names are an edge case in the grammar, with 307 occurrences on the \texttt{_xlnm.Print_Area} and 3 occurrences of  \texttt{_xlnm.Database}.

Regarding function arguments, spreadsheet systems allow empty ones but this is rarely done -in only 0.05\% of the formula cells. Array arguments are also an edge case. Only 385 formula cells contain an array used as argument, e.g. \texttt{=LARGE((F38,C38),1)}. All occurrences were arguments of the \texttt{LARGE} and \texttt{SMALL} functions. In the Euses dataset we also found 19 cases of array formulas used as arguments, e.g. \texttt{=FVSCHEDULE(1,{0.09;0.11;0.1})}. ???

\subsubsection{References}
 
Spreadsheet formulas allow for different types of references, including single cell references, cell ranges, horizontal or vertical ranges, named ranges and reference-returning build-in or user-defined functions. All of these references can be internal (in the same or in different sheets) or external. Syntactically, they can be expressed in a number of ways. The simplest case of a reference to a cell range can be expressed in any of the following ways:

\begin{eqnarray*}
\texttt{SUM(A1:A2)} \\ 
\texttt{= SUM(Sheet1!A1:A2)} \\
\texttt{= SUM(Sheet1!A1:(A2))} \\
\texttt{= SUM('Sheet1'!A1:A2)} \\
\texttt{= SUM(Sheet1!A1:Sheet1!A2)} \\
\texttt{= SUM(Sheet1!A1:'Sheet1'!A2)} \\
\end{eqnarray*}

The \synt{Reference} rule covers all types of referencing expressions. It was the rule that was the most complex to devise to cover all edge cases in the two datasets. Its syntax diagram, expanded to include terminal tokens, is shown above(???).

\begin{figure*}
	\centering
	\begin{grammar}
		<Reference> ::= \[[
		\begin{stack} '$($' <Reference> '$)$'\\ <Reference> \begin{stack} '$:$' \\ '$ $' \end{stack} <Reference> \\
		\begin{stack} \\ \begin{stack} \\ "FILE" \end{stack} \begin{stack} "SHEET" \\ "MULTIPLE_SHEETS" \end{stack} \\ "FILE" '$!$' \\ "QUOTED_FILE_SHEET" \end{stack}
		\begin{stack} \begin{stack} \begin{stack} "CELL" \\ "REFERENCE-FUNCTION" <Arguments> '$)$' \end{stack} \\ "VERTICAL-RANGE" \\ "HORIZONTAL-RANGE" \\ \begin{stack} "NAMED-RANGE" \\ "NAMED-RANGE-COMBINED" \end{stack} \\ "ERROR" \end{stack} \\ "UDF" <Arguments> '$)$'\end{stack}
		\end{stack}
		\]]
	\end{grammar}
\end{figure*}

As shown in Table \ref{table:occurences}, 99.3\% of the formulas in the two datasets contain at least one \synt{Reference}, and 25\% of the formulas contain a reference that is not local, since it includes a \synt{Prefix}. External file references exist in almost 5\% of the formulas. 17\% of the formulas include a reference with a simple (\texttt{':'} separated) cell range. Named ranges exist in 7.33\% of formulas and, interestingly, horizontal and vertical ranges are rarely used (jointly, in 0.25\% of the formulas). References to errors are relatively common, with 0.65\% of formulas including errors like \texttt{=\#REF!E3}.

Moving to the edge cases of the grammar, the structures that were less common in the datasets include:

\begin{description}
	\item[File-only external references] \hfill \\
		External references are normally in the form \texttt{[File]Sheet!Cell}. In almost 30,000 formula cells (0.12\%), however, the sheet is not specified, e.g. \texttt{=[2]!LastTrade}. These are either cases of references to external named ranges or to external UDFs.
	\item[Multiple sheet references] \hfill \\
	 Almost 2,000 cells (0.01\%) contain this complex case of reference, which spans across multiple sheets. An example formula is \texttt{=SUM(Sheet1:Sheet10!A5)}, evaluated by summing all cells in position \texttt{A5} from \texttt{Sheet1} to \texttt{Sheet10}.
	\item[References to external UDFs] \hfill \\
	855 cells contain references to external user-defined functions, for example \texttt{=[1]!SheetName()}.
	\item[Prefixed right limits] \hfill \\
	1,501 cells include a reference with a prefix in the right limit, e.g. \texttt{=SUM(Deals!F9:'Deals'!F16)}. In all cases this prefix is identical to the first one, as continuous ranges spanning across multiple sheets are not supported by Excel. Still, this syntax is supported.
\end{description}

A special edge case in the grammar are the functions that return references, namely the \texttt{INDEX}, the \texttt{OFFSET} and the \texttt{INDIRECT} functions -this is to the best of out knowledge, since the Excel functions reference guide does not enable filtering functions based on their output type and these three were the only functions that were found in the two datasets to be returning references. The \texttt{OFFSET} funtion, for example, returns a reference to a range that is a specified number of rows and columns from a cell or range of cells. An example formula utilizing it is \texttt{=STDEV(F399:OFFSET(F399,-(B17-1),0,1,1))}. Those functions are relatively common: they are found in 3.36\% of the formula cells, with the most common one being the \texttt{INDEX} (in 2.38\% of formula cells) and the least common one being the \texttt{INDIRECT} (in 0.21\%).

Finally, dynamic data exchange links are a special case of references. They are used for receiving data from other applications, and they are defined as \texttt{ProgramName|Topic!Field}, e.g. \texttt{=TWINDDE|RSFRecord!'NGH2 NET.CHNG'} or \texttt{=GLDDEML|Action!'SGIMP,LA'/100}. 3,686 formula cells are found in the datasets to include this type of reference.

todo: add DDE to grammar!
 
\subsubsection{Smelly grammar constructs}
Having analyzed extensively the grammar of spreadsheets, there are two constructs that we consider to be smelly, i.e. counterintuitive, inconsistent to the rest of the grammar and error-prone: Complex ranges and the implicit intersect operator.

By \textit{complex ranges} we mean \synt{Reference}s that include more than two or different types of $':'$ separated \synt{ReferenceItem}s. For example, range \texttt{B2:D4:C1}. Their smelly aspect is their evaluation. Normal cell ranges are in the form \texttt{startingLimit:endingLimit}, including all cells in between the two limits. However, the limits in complex ranges are not the ones specified in the formula: they are calculated as the upper leftmost and lower rightmost cell in the square that includes all defined cells. In the \texttt{B2:D4:C1} example, cell \texttt{B1} is also included in the range. Understanding the limits of the range becomes even less intuitive when named ranges and vertical or horizontal ranges are added. Moreover, this syntax does not add to expressiveness of the grammar: each range is still calculated as the cells within a single square, but without clearly user-defined limits. The analysis showed that complex ranges are rare: 8,566 formula cells	(0.04\%) include complex ranges in the Enron dataset, and they are all defined using three cell locations. 

The \textit{intersect operator} is included in this discussion because it is not declared as an operator. Intersection between two ranges in the grammar is represented in the most implicit way possible: by \texttt{\char32}, a single whitespace. For example, \texttt{A1:A10\char32A1:A5} is equivalent to \texttt{A1:A5}. Using this syntax, intersection is an implicit range formation operation, belonging to the \synt{Reference} rule, rather than a normal operation declared as a the \synt{Function}. An advantage of this approach is that it enables more natural language definition of intersections, e.g.  \texttt{=SUM((Total_Cost Jan):(Total_Cost Apr.))}. An alternative, in our opinion less error-prone definition of intersection, would be a dedicated build-in function used explicitly as \texttt{INTERSECT(A1:A10,A1:A5)}. In the two datasets, intersection operations are not common, as they are found in only 2,446 cases of formula cells.

\subsection{Limitations}
todo: check if the features below are supported in other spreadsheet systems

todo: add that the datasets are both Excel spreadsheets only

todo: note that we verified that it covers all cased of formulas that excel covers, but we cannot verify that its coverage is not greater than Excel: it might be more forgiving.

The evaluation of the grammar does not include array formulas. Those are specified as formulas surrounded by brackets, for example \texttt{\{= SUM( A1:E1*\{1,2,3,4,5\})\}}, that perform multiple calculations on array items. The grammar is designed to recognize array formulas as regular formulas surrounded by brackets (\synt{ArrayFormula} rule). However, due to limitations of the Gembox library that our tool uses for reading the formulas from the spreadsheets, array formulas are read and fed to the parser as regular formulas, without the surrounding brackets. For this reason, we can neither evaluate this case in terms of grammar support, nor can we extract information on their frequency in the two datasets.

Other limitations of the proposed grammar concern syntactical features that have been discontinued, like regular expressions in formulas. Excel allows defining formulas that include regular expressions, for example \texttt{=SUM('S*'!A1)} or \texttt{=SUM('Sheet?'!A1)}. However, in Excel 2010 and up (are we sure???), regular expressions are instantly resolved -in the example, to the multiple sheet reference \texttt{=SUM(Sheet2:Sheet3!A1)}, summing up all \texttt{A1} cells between \texttt{Sheet2} and \texttt{Sheet3}, where the sheets are all matching sheets, except the one that this formula is on. This way, in latest versions of Excel, saved spreadsheets never contain regular expressions. Also in the two datasets there was no such case, even though ??\% of the spreadsheets are in prior to Excel 2007 format (.xls files). 

The use of labels in formulas (a.k.a. natural language formulas) is another feature that was discontinued in Excel 2007. Labels were the headings that were typed above rows and columns, and they could be used in formulas instead of defined names or cell ranges. For example, formula \texttt{=Product A First Quarter} would return the intersection between the cell range with heading \texttt{Product A} and the one with heading \texttt{=First Quarter}. This feature is replaced in newer versions of Excel with the less error-prone named ranges feature. The proposed grammar does not support it, and it would mistakenly parse the labels as named ranges.

\subsubsection{Internationalization}

Excel formulas differ depending on the language of the software. For example function arguments are separated by a semicolon instead of a comma in locales that use the comma as a decimal separator.

Our grammar is only for the default (English) locale. Grammars for other locales can be gotten by replacing delimiters, error values and function names by their localized versions.

It is worth noting that Excel will always save formulas in either a locale-independent binary format (Excel 2003 and earlier format) or in its English version (Excel 2007 and later format). When interacting with Excel through its API two versions of the formula can be read or written: the English version and the version in the current locale.
This makes a grammar for the English version quite useful.

\subsection{Application}
The abstract syntax trees that the parser produces are traversed to generate information like the references of cells to other cells -in the form of internal or external ranges of any kind, the types of functions used, the operations and the fixed numbers in formulas. This information is used to perform more complex calculations on the cell dependencies, the calculation chains and possible smells on those. The parser has already been used in reference \cite{EnronVSEuses} to extract information like the intra-worksheet connections, the external links, the transitive precedents and the preceding cells of formulas. Also, in ???? (other published work?) - refer to papers Enron, smells, bumblebee

\section{Related work}
- on inferring and testing undefined grammars
- on analyzing spreadsheets using some sort of grammar
- our work

\section{Conclusion}
future work:
comparison with the official grammar using grammar comparison techniques


\section*{Acknowledgment}
The authors would like to thank...


\bibliographystyle{IEEEtran}
\bibliography{XLGrammarRefs}



\end{document}


