% smrdoc.tex V2.10, 13 July 2012
\documentclass[times]{smrauth}
%When you submit your paper, please use the command
%\def\baselinestretch{2}
% or \documentclass[times, doublespace]{smrauth}

% Syntax package configuration
\usepackage[rounded]{syntax}
\setlength{\grammarparsep}{4pt plus 1pt minus 1pt}

% multiple images
\usepackage{subcaption}

% Parse trees
\usepackage{forest}

\usepackage[hyphens]{url}
\usepackage[hidelinks]{hyperref}

\usepackage{rotating}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\begin{document}

\runningheads{E.~Aivaloglou et al.}{Parsing Excel formulas}

\title{Parsing Excel formulas: A grammar and its application on four large datasets}

\author{Efthimia Aivaloglou\affil{1}\corrauth, David Hoepelman\affil{1}, Felienne Hermans\affil{1}}

\address{Software Engineering Research Group, Delft University of Technology, Mekelweg 4, 2628 CD, Delft, The Netherlands}

\corraddr{Software Engineering Research Group, Delft University of Technology, Mekelweg 4, 2628 CD, Delft, The Netherlands. E-mail: e.aivaloglou@tudelft.nl}

\begin{abstract}
Spreadsheets are popular end-user programming tools, especially in the industrial world. This makes them interesting research targets. However, there does not exist a reliable grammar that is concise enough to facilitate formula parsing and analysis and to support research on spreadsheet codebases.
This paper presents a grammar for spreadsheet formulas that can successfully parse 99.99\% of more than eight million unique formulas extracted from four spreadsheet datasets. Our grammar is compatible with the spreadsheet formula language, recognizes the spreadsheet formula elements that are required for supporting spreadsheets research, and produces parse trees aimed at further manipulation and analysis. 
Additionally, we utilize the grammar to analyze the characteristics of the formulas of the four datasets in three different dimensions: complexity, functionality and  data utilization. Our results show that 1)
most Excel formulas are simple, however formulas with more than 50 functions or operations exist,
 2) almost all formulas use data from other cells, which is often not local, and
 3) a surprising number of referring mechanisms are used by less than 1\% of the formulas.
\end{abstract}

\keywords{spreadsheets; syntax; formula grammar}

\maketitle

\section{Introduction}
Spreadsheets are widely used in industry: Winston~\cite{Wins2001} estimates that 90\% of all analysts in industry perform calculations in
spreadsheets. Their use is diverse, ranging from inventory administration to educational applications and from scientific
modeling to financial systems. In a survey held in 2003 by the US Bureau of Labor Statistics \cite{stats}, over 60\% of 77 million surveyed workers in the US reported using spreadsheets, making this the third most common use of computers, after email and word processing. A more recent survey among 95 companies world-wide placed spreadsheets fourth, after email, browsing and word processing, accounting for 7.4\% of computer time \cite{stats2}. It is estimated that the number of spreadsheet programmers is bigger than that of software programmers \cite{DBLP:conf/vl/ScaffidiSM05, SANERAll}. 

Because of their widespread use, spreadsheets have been the topic of research since the nineties \cite{DBLP:journals/sigplan/BellP93}. Recent research has often focused on analyzing and visualizing spreadsheets \cite{DBLP:conf/icse/HermansPD11, Shio1999}. More recently, researchers have attempted to detect data and table clones in spreadsheets 
\cite{Hermans:clones, Dou2016} and to define \emph{spreadsheet smells}: applications of Fowler's code smells to spreadsheets \cite{DBLP:conf/icse/HermansPD12, DBLP:conf/icsm/Hermans212, custodes}, followed by approaches to refactor spreadsheets \cite{hermans2014bumblebee,badame2012refactoring} and to apply testing practices on spreadsheets \cite{Expector}. These research works analyze the formulas within spreadsheets, and therefore often involve formula parsing. This is done either by using simple grammars which have not been evaluated (\cite{badame2012refactoring}), or through implied, undefined grammars (\cite{DBLP:conf/icse/HermansPD11, Dou2016, DBLP:conf/icse/HermansPD12, DBLP:conf/icsm/Hermans212, custodes, hermans2014bumblebee, Expector}). 

The above analyses are our main motivation towards defining a formula grammar. Having such a grammar will enable parsing spreadsheet formulas into processable parse trees which can in turn be used to analyze cell references, extract metrics, find code smells and explore the structure of spreadsheets. Essentially, a reliable and consistent grammar and its parser implementation, available to the spreadsheet research community, can support research on spreadsheet formula codebases and can enhance the understanding and usability of research results. To make a grammar suitable for this goal, the requirements that we set for it are to be compatible with the official Excel formula language, to produce parse trees suited for further manipulation and analysis, and to recognize the spreadsheet formula elements that are required for supporting spreadsheets research.

We further utilize the grammar to analyze more than eight million unique formulas originating from the three major datasets available in the spreadsheet research community, namely EUSES \cite{euses}, Enron \cite{enron} and FUSE \cite{fuse}, along with a fourth dataset of that we accumulated through crawling the WikiLeaks website.  The goal of the analysis is to obtain an understanding of how people program in the spreadsheets formula language by quantitatively evaluating the characteristics of spreadsheet formulas in terms of complexity, functionality and data utilization. Specifically, we explore the following research questions:

\begin{itemize}
	\item[RQ1] What are the size and complexity characteristics of Excel formulas?
	\item[RQ2] Which types of functions and operations are commonly invoked in formulas?
	\item[RQ3] How is input data used in formulas?
\end{itemize}


The contributions of this paper are (1) a concise grammar for spreadsheet formulas, (2) the evaluation of the compatibility of the grammar using four major datasets, and (3) an exploratory study of the formulas in the datasets in terms of complexity, utilized data and functionality.

The remainder of the paper is organized as follows: in the following section we summarize the basic concepts of spreadsheets and of the formula language. In Section \ref{section:grammar} we discuss our design process and present the spreadsheet formula grammar, its lexical and syntactical analysis rules, and details on precedence and ambiguity. Section \ref{sec:evaluation} explains how we implemented and evaluated the grammar. The analysis of the datasets with respect to the research questions is presented in Section \ref{section:results}. In Section \ref{sec:discussion} we discuss the grammar and its limitations. Section \ref{section:relatedWork} presents related work and Section \ref{section:conclusion} concludes the paper.

\section{Background}

Spreadsheets are cell-oriented dataflow programs which are Turing complete \cite{ExcelTuringComplete}.
A single spreadsheet \emph{file} corresponds to a single (\emph{work})\emph{book}.
A workbook can contain any number of (\emph{work})\emph{sheets}.
A sheet consists of a two-dimensional grid of \emph{cells}.
The grid consists of horizontal \emph{rows} and vertical \emph{columns}.
Rows are numbered sequentially top-to-bottom starting at 1, while columns are numbered left-to-right alphabetically, i.e. base-26 using A to Z as digits, starting at `A', making column 27 `AA'.

A cell can be empty or contain a \emph{constant value}, a \emph{formula} or an \emph{array formula}.
Formulas consist of expressions which can contain constant values, arithmetic operators and \emph{function calls} such as \texttt{SUM(\ldots)} and, most importantly, \emph{references} to other cells.
Functions can be built-in or user-defined (UDFs), which are created using the Visual Basic for Applications programming language.

\subsection{References}
\label{subsec:references}
References are the core component of spreadsheets.
The value of any cell can be used in a formula by concatenating its column and row number, producing a reference like \texttt{B5}.
If the value of a cell changes, this new value will be propagated to all formulas that use it.

When copying a cell to another cell by default references will be adjusted by the offset, for example copying \texttt{=A1} from cell B1 to C2 will cause the copied formula to become \texttt{=B2}.
This can be prevented by prepending a \texttt{\$} to the column index, row index or both.
The formula \texttt{=\$A\$1} will remain the same on copy while \texttt{=\$A1} will still have its row number adjusted.

References can also be \emph{ranges}, which are collections of cells.
Ranges can be constructed by three operators: the range operator \texttt{:}, the union operator \texttt{,} (a comma) and the intersection operator \texttt{\char32} (a single whitespace).
The range operator creates a rectangular range with the two cells as top-left and bottom-right corners, so \texttt{=SUM(A1:B10)} will sum all cells in columns A and B with row number 1 through 10.
The range operator is also used to construct ranges of whole rows or columns, for example \texttt{3:5} is the range of the complete rows three through five.
The union operator, which is different from the mathematical union as duplicates are allowed, combines two references, so \texttt{A1,C5} will be a range of two cells, \texttt{A1} and \texttt{C5}.
Lastly the intersection operator returns only the cells which are occurring in both ranges, \texttt{=A:A 5:5} will thus be equivalent to \texttt{=A5}.

A user can also give a name to any collection of cells, thus creating a \emph{named range} which can be referenced in formulas by name. Cells can also be grouped into \emph{tables}, which can be used in \emph{structure references}. This is a special case of references, introduced in Excel 2007, that allow the use of keywords and table headers as row and column specifiers.

\subsection{Sheet and External References}
\label{subsection:ExternalRefsDDE}

By default, references point to cells or ranges in the same sheet as the formula. This can be modified with a prefix. A prefix consists of an identifier, followed by an exclamation mark, followed by the actual reference.

A reference to another sheet in the same workbook is indicated by using the sheetname as prefix: \texttt{=Sheetname!A1}. References to external spreadsheet files are defined by prepending the file name in between square brackets: \texttt{=[Filename]Sheetname!A1}.
A peculiar type of prefix are those that indicate multiple sheets: \texttt{=Sheet1:Sheet10!A1} means cell A1 in Sheet1 through Sheet10.
Sheet names are enclosed in single quotes if they contain special characters or spaces, e.g. \texttt{='Sheetname with space'!A1}. 

\subsection{Array Formulas and Arrays}
\label{sec:arrayformulas}
In most spreadsheet programs it is possible to work with one- or two-dimensional matrices. When constructed from constant values they are called \emph{array constants}, e.g. \texttt{\{1,2;3,4\}}.
They are surrounded by curly brackets, columns are separated by commas, and rows by semicolons.
Several matrix operations are available, for example \texttt{=SUM(\{1,2,3\}*10)} will evaluate to 60.

\emph{Array Formulas} use the same syntax as normal formulas, except that the user must signal that it is an array formula, usually by pressing \emph{Ctrl} + \emph{Shift} + \emph{Enter}.
Marking a formula as an array formula will enable one- or two-dimensional ranges to be treated as arrays.
For example, if \texttt{A1},\texttt{A3},\texttt{A3} contain the values \texttt{1},\texttt{2},\texttt{3}, the array formula \texttt{\{=SUM(A1:A3*10)\}} will evaluate to \texttt{60}.

\section{Spreadsheet Formula Grammar}
\label{section:grammar}

For previous and ongoing research the authors needed a grammar for Microsoft Excel spreadsheet formulas with the following requirements:

\label{sec:designgoals}
\begin{enumerate}
	\item Compatibility with the official language
	\item Produce parse trees suited for further manipulation and analysis with minimal post-processing required
	\item Recognize the spreadsheet formula elements required for supporting spreadsheets research
\end{enumerate}

While an official grammar for Excel formulas is published \cite{ExcelOfficialGrammar}, it is too granular for our purpose ---it is over 30 pages long and contains hundreds of production rules. Because of its detail and the large number of production rules, the resulting parse trees are very complex and thus fail requirement 2.
An example is given in Figure \ref{figure:parsetrees}(a): the relatively simple formula \texttt{SUM(B2,5)} results in a 37-node tree with a depth of 18 nodes. 

For our purpose of facilitating research on spreadsheet formulas, we need a grammar that provides a different level of detail, just-enough to satisfy requirement 3. Examining previous research works (including \cite{DBLP:conf/icse/HermansPD11,DBLP:conf/icse/HermansPD12, DBLP:conf/icsm/Hermans212, hermans2014bumblebee, badame2012refactoring, Expector}), we find that the spreadsheet formula elements that a grammar for this purpose needs to recognize include functions calls (of build-in and user-defined functions), function arguments, data (of different types) and references (to internal and external cells and ranges of different types).

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\hspace{-2em}
		\scalebox{.7}{
			\input{floats/parsetree-ms-sumb25}
		}
		\caption{Microsoft Excel parse tree, constructed based on reference \cite{ExcelOfficialGrammar}}
	\end{subfigure}
	~
	%\end{figure}
	%\begin{figure}
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\vspace{1em}
		\hspace{-0.5em}
		\scalebox{.7}{
			\input{floats/parsetree-ours-sumb25}
		}
		\caption{Parse tree produced using the grammar defined in this paper}
		\label{figure:ourparsetree}
	\end{subfigure}
	\caption{Parse trees for formula \texttt{SUM(B2,5)}}
	\label{figure:parsetrees}
\end{figure}

For these reasons the authors decided to construct a new grammar with the above requirements as design goals.

\subsection{Design Process}

The approach that we followed towards developing the grammar was gradual enrichment through trial-and-error: we started from a simple grammar containing only the most common and well known formula structures and implemented it using a parser generator. Subsequently, we repeatedly tested it against formulas extracted from spreadsheet datasets, leading to further enrichments and refinements, until all common and rare cases found in the datasets were supported. 

For the first version of the grammar \cite{XLparser} we used the two major datasets that were available in the spreadsheet research community at the time, namely the EUSES dataset \cite{euses} and the Enron \cite{enron} corpus, from which we extracted 1,035,586 unique formulas. From the simple grammar that we started from until the published version that parses 99.99\% of those formulas, we fixed a total of 85 parse issues. We used GitHub for tracking the parse errors that were produced and pull requests for integrating fixes and refinements to the parser.

Since that version, two factors facilitated further refinement of the grammar: first, making its parser open source and increasing its visibility following \cite{XLparser} enabled users to test it with their datasets and discover new parse errors. This was the case with structured references, which the grammar did not support because they are a relatively new feature, not used in the formulas of the EUSES or the Enron datasets. Second, two new large datasets became available for testing, the FUSE corpus \cite{fuse} and a dataset that we accumulated by crawling the WikiLeaks website, jointly containing over 7,541,840 unique formulas.

Once the grammar presented in \cite{XLparser}, enriched to support structured references, was tested against the new datasets, we found that 1,387 of those formulas were not parsed. The process that we followed was similar as with the first two datasets: initially, for each formula we did a preliminary search for the reason causing the parse failure and we grouped the failing formulas into 7 categories of parse errors. Then we modified or enriched the grammar with the missing lexical or syntactical constructs, updated the parser implementation, added unit tests, and re-tested against the datasets, repeating the process until all but 457 formulas were successfully parsed ---as explained later in Section \ref{subsection:unparsableFormulas}, all but 2 of those formulas do not cause actual parse errors.

\subsection{Grammar Class}
\label{sec:grammarclass}
While the class of this grammar is not strictly LALR(1) due to the ambiguity that will be discussed in Section \ref{sec:ambiguity}, we implemented this grammar using a LALR(1) parser generator.
The present ambiguity can be solved by defining operator precedence (section \ref{sec:operatorprecedence}) and manually resolving conflicts (Section \ref{sec:ambiguity}).
These two features are supported by most LALR(1) parser generators.

\subsection{Lexical Analysis}
Table \ref{table:tokens} contains the lexical tokens of the grammar, along with their identification patterns in the regular expression language and their priorities. All tokens are case-insensitive.
Characters are defined as unicode characters x9,xA,xD and x20 and upwards.

\begin{sidewaystable}
	\vspace{2mm}
	\caption{Lexical tokens used in the grammar}
	\label{table:tokens}
	\centering
	\input{floats/table-tokens}
\end{sidewaystable}

Some simple tokens (e.g. '\%', '!') are directly defined in the production rules in Section \ref{subsection:productionRules} in between quotes for readability and compactness.

\subsubsection{\textbf{Dates}}

The appearance of date and time values in spreadsheets depends on the presentation settings of cells. Internally, date and time values are stored as positive floating point numbers with the integer portion representing the number of days since a Jan 0 1900 epoch and the fractional portion representing the portion of the day passed.

For this reason, the grammar only parses numeric dates and times and these are not distinguishable from other numbers.

\subsubsection{\textbf{External References}}
\label{section:externalReferences}
The file names of external references in formulas are not stored as part of the formula in the Microsoft Excel storage format, but instead are replaced by a numeric index.
This index is then stored in a file level dictionary of external references.
A formula that is presented to the user as \texttt{=[C:\textbackslash Path\textbackslash Filename.xlsx]Sheet1!A1} is internally stored as \texttt{[X]Sheet1!A1}, where \texttt{X} can be any number.

For this reason the presented grammar supports only numeric file names in external references.
Adding support for full filenames can be achieved by introducing an additional token or altering the \texttt{FILE} token. Note that external filenames can be presented to, and entered by, the user in a number of different formats, depending on conditions such as whether or not the file is open in the spreadsheet program.

\subsection{Syntactical Analysis}
\label{subsection:productionRules}

The complete production rules of our grammar in Extended BNF syntax are listed below.
Patterns inside \{ and \} can be repeated zero or more times.
The start symbol is $Start$. An example parse tree produced using this grammar is drawn in Figure \ref{figure:parsetrees}(b).

\input{floats/grammarrules}

\synt{Formula} and \synt{Reference} are the two most important nonterminals of the grammar.
These are also illustrated as syntax diagrams, with most production rules expanded, in Figures \ref{figure:Formula} and \ref{figure:Reference}.

\begin{figure}[]
	\input{floats/railroad-formula}
	\caption{Syntax diagram of the \synt{Formula} production rule with most production rules expanded}
	\label{figure:Formula}
\end{figure}

\begin{figure}[]
	\centering
	\input{floats/railroad-reference}
	\caption{Syntax diagram of the \synt{Reference} production rule with most production rules expanded}
	\label{figure:Reference}
\end{figure}

The \synt{Formula} rule covers all types of spreadsheet formula expressions: they can be constants (\texttt{=5}), references (\texttt{=A3}), function calls (\texttt{=SUM(A1:A3)}), array constants (\texttt{=\{1,2;3,4\}}, explained in Section \ref{sec:arrayformulas}), or reserved names (\texttt{=_xlnm.Print_Area}). Function calls invoke actual named (built-in or user defined) functions or operators applied to one or more formulas. A special case of built-in functions are those that always return references, namely the \texttt{INDEX}, \texttt{OFFSET} and \texttt{INDIRECT} and the conditional functions that sometimes return references, namely \texttt{IF} and \texttt{CHOOSE}.
For example, \texttt{INDEX} returns the reference of the cell at the intersection of a particular row and, optionally, column, so \texttt{INDEX(B1:B10,3)} returns a reference to cell \texttt{B3} and can be used in a formula as \texttt{=SUM(A1:INDEX(B1:B10,3))} being equivalent to \texttt{=SUM(A1:B3)}.

The \synt{Reference} rule covers all types of referencing expressions, which are diverse. The simple case of a reference to a cell range can be expressed in any of the following ways:

\begin{align}
	\texttt{SUM(A1:A2)} \\ 
	\texttt{= SUM(Sheet!A1:A2)} \\
	\texttt{= SUM(Sheet!A1:(A2))} \\
	\texttt{= SUM('Sheet'!A1:A2)} \\
	\texttt{= SUM(Sheet!A1:Sheet!A2)} \\
	\texttt{= SUM(namedRangeA1A2)} \\ 
	\texttt{= SUM(A1,A2)} \\ 
	\texttt{= SUM((A1,A2))} \\ 
	\texttt{= SUM(A1:A2:A1)} \\
	\texttt{= SUM(A1:A2 A:A)} 
\end{align}

The \synt{Reference} rule, as shown in Figure \ref{figure:Reference}, supports internal (in the same or in different sheets), or external single cell references, cell ranges, horizontal and vertical ranges, named ranges and reference-returning, built-in or user-defined, functions.

\subsection{Operator Precedence}
\label{sec:operatorprecedence}

All operators in Excel are left-associative, including the exponentiation operator, which in most other languages is right-associative.
In order to resolve ambiguities, a LALR parser generator needs the operator precedence to be defined as listed in Table \ref{table:operatorprec}.

\begin{table}[]
	\centering
	\caption{Operator precedence in formulas}
	\label{table:operatorprec}
	\input{floats/table-precedence}
\end{table}

\subsection{Intersection Operator}
\label{sec:intersection}
The intersection binary operator in Excel formulas is a single space.
While this is straightforward to define in EBNF, it can be challenging to implement using a parser generator.

The parser generator we used for implementing the grammar supports a feature called implicit operators which was used to implement this operator.
Implicit operators are operators which are left out and only implied, for example in calculus the multiplication operator is often omitted: $5a$ is equivalent to $5 \cdot a$.

\subsection{Ambiguity}
\label{sec:ambiguity}

Due to trade-offs on parsing references (see Section \ref{tradeoff:references}) and on parsing unions (see Section \ref{subsec:desing:unions}) our grammar is not fully unambiguous.
Ambiguity exists between the following production rules:
\begin{enumerate}
	\item \begin{grammar}<Reference> ::= `(' <Reference> `)'\end{grammar}
	\item \begin{grammar}<Union> ::= `(' <Reference> \{ `,' <Reference> \} `)'\end{grammar}
	\item \begin{grammar}<Formula> ::= `(' <Formula> `)'\end{grammar}
\end{enumerate}

A formula like \texttt{=(A1)} can be interpreted as either a bracketed reference, a union of one reference, or a reference within a bracketed formula.

In a LALR(1) parser the ambiguity manifests in a state where, on a \texttt{')'} token, shifting on rule 1 and reducing on either rule 2 or 3 are possibilities, causing a shift-reduce conflict.
This was solved by instructing the parser generator to shift on Rule 1 (bracketed \synt{Reference}) in case of this conflict, because this always is a correct interpretation and thus results in correct parse trees.

\subsection{Trade-offs}

\subsubsection{\textbf{References}}
\label{tradeoff:references}

References are of great importance in spreadsheet formulas, and thus of interest for analysis.
To support easier analysis (Design goal 2) references have different production rules than other expressions.
This causes references to be easily identified and isolated, but has the downside of increasing ambiguity, as explained in Section \ref{sec:ambiguity}. 

Another approach would be to parse all formulas similarly and implement a type system, however this would be detrimental to ease of implementation (Design goal 3).

\subsubsection{\textbf{Unions}}
\label{subsec:desing:unions}

The comma serves both as an union operator and a function argument separator.
This proves challenging to correctly implement in a LALR(1) grammar.

A straightforward implementation would use production rules similar to this:
\begin{grammar}
	<Union> ::= <Reference> \{ `,' <Reference> \}

	<Arguments> ::= <Argument> \{ `,' <Argument> \} | $\epsilon$
\end{grammar}

However, this will cause a reduce-reduce conflict because the parser will have a state wherein it can reduce to both a \synt{Union} or an \synt{Argument} on a \texttt{,} token.
Unfortunately there is no correct default choice: in a formula like \texttt{=SUM(A1,1)} the parser must reduce on the \synt{Argument} nonterminal, while in a formula like \texttt{=A1,A1} the parser must reduce to the \synt{Union} nonterminal.
With the above production rules a LALR(1) parser could not correctly parse the language.

The presented grammar only parses unions in between parentheses, e.g. \texttt{=SMALL((A1,A2),1)}.
This is a trade-off between a lower compatibility (Design goal 1) and an easier implementation (Design goal 3).
We deem this decreased compatibility to be acceptable since unions are very rare (discussed in Section \ref{section:results}) and, in the datasets we used, all but two were with parentheses (Section \ref{subsection:unparsableFormulas}).

\section{Evaluation and Dataset}
\label{sec:evaluation}

In this section we explain how we implemented and evaluated the grammar using four large datasets and we discuss the obtained results and formula parse failures.

The grammar is implemented using the Irony parser generator framework\footnote{\url{https://irony.codeplex.com/}}. Irony fulfills the requirements set in Section \ref{sec:grammarclass}: it is a LALR(1) parser generator, is enables defining operator precedence as listed in Table \ref{table:operatorprec}, and it includes a method, \texttt{PreferShiftHere()}, for resolving shift-reduce conflicts as specified in Section \ref{sec:ambiguity}. In addition, Irony enables defining terminals that produce tokens with empty text through a special terminal type, \texttt{ImpliedSymbolTerminal}, which we used for defining the intersection operator explained in Section \ref{sec:intersection}. At the same time, with Irony the entirety of the grammar was coded directly in C\#, which enabled streamlining the development of the parser and of its evaluation tools in the .NET platform.

The resulting parser, named XLParser, is available for download\footnote{\url{https://github.com/PerfectXL/XLParser}}. An online demo is also available.\footnote{\url{http://xlparser.perfectxl.nl/demo}}

To extract unique formulas from spreadsheets and use them as input to the parser we built a tool that opens spreadsheets using a third-party library called Gembox\footnote{\url{http://www.gemboxsoftware.com/}} and converts the ones in Excel version prior to 2007 (with \texttt{xls} file extension) to Excel 2007 format. This tool reads all cells and identifies the formulas that are unique when adjusted for cell location (R1C1 representation), thus rejecting the formulas with adjusted references due to cell copying (e.g. formulas \texttt{=C1} and \texttt{=C2} are considered the same if contained in cells A1 and A2 respectively). The tool then uses each unique formula string as input to the parser.

To evaluate the grammar we attempt to parse a total of 8,577,426 unique formulas. These originate from the three major datasets available in the spreadsheet research community, the EUSES dataset \cite{euses}, published in 2005 and consisting of 4,498 spreadsheets, the Enron email corpus \cite{enron}, which became available after the Enron company declared bankruptcy in 2001, consisting of 16,190 spreadsheets, and the recently published FUSE corpus \cite{fuse}, consisting of 249,376 spreadsheets, along with a fourth dataset of 109,475 spreadsheets that we accumulated through crawling the WikiLeaks website. The original spreadsheets in the datasets are of various Excel versions. The Euses and the Enron datasets contain spreadsheets in the Excel binary file format (\texttt{.xls} files), while the last two datasets include more recent spreadsheets, saved in Excel 2007 and later workbook format (\texttt{.xlsx}, \texttt{.xlsm} and \texttt{.xlsb} files). We were not able to process 13,481 (3.55\%) of all spreadsheets, either because they are password protected, or because of read failures in the Gembox library. Table \ref{table:datasets} summarizes the data obtained from each dataset. In total, the 366,058 spreadsheets that were processed from the four datasets include 189,340,714 formula cells with 8,577,426 unique formulas.

\begin{table}[]
	\centering
	\caption{The datasets used for evaluation and analysis}
	\label{table:datasets}
	\input{floats/table-datasets}
\end{table}

Out of the 8,577,426 unique formulas that were used as input to the parser, 8,576,969 (99.99\%) were parsed successfully, with 2 of the failing ones being actual parse errors, as will be explained in the following section.

\subsection{Unparsable Formulas}
\label{subsection:unparsableFormulas}
The 457 formulas that were not parsed using the grammar defined in Section \ref{section:grammar} are:

\begin{itemize}
	\item \texttt{=-NOX, Regi} and \texttt{=-_SO2, Regi}, found in two different workbooks in the Enron dataset. These are cases of an union operations without parentheses that the grammar does not parse as explained in Section \ref{subsec:desing:unions}.
	\item 28 formulas originating from 13 spreadsheets that Excel does not evaluate either. Those formulas include indecipherable characters, for example \texttt{=+Ã‹\%} in a file that appears to be corrupt, and they result in \texttt{\#NAME?} errors.
	\item 371 formulas originating from 67 spreadsheets that are not returned correctly from the Gembox library. For example, our tool reads and attempts to parse the formula \texttt{=1 SUMM BS!A3:K3} and fails, but in reality the formula is \texttt{='1 SUMM BS'!A3:K3} which can be parsed. All these 371 cases were parsed successfully when we exported them into a flat file, manually corrected them to match their original form, and provided them as input to the parser.
	\item 56 formulas originating from 2 spreadsheets that include filenames with brackets and are not returned correctly as numeric. For example, formula \texttt{='C:\textbackslash[FY2014WSSBBasic[1].xls].xls]Basic Grant'!A6} is read as \texttt{='[1].xls].xls]Basic Grant'!A6}, which is not parsed, as the grammar is designed to support numeric-only filenames for the reasons explained in Section \ref{section:externalReferences}. All those 56 cases are parsed successfully when the filename is replaced with a numeric one.
\end{itemize}

\section{Results}
\label{section:results}
In the following sections, for each of the research questions, we describe the results obtained through the analysis of the 8,576,969 parsed unique formulas in the dataset.

\subsection{Formula Complexity}

The complexity of the formulas is reflected in the structure of the produced parse trees. To demonstrate how the parse trees can be used for analyzing formula characteristics, we calculated four formula complexity indicators:  the number of functions and constants, the conditional depth, the formula depth, and the operator depth. The results, in terms of number of unique formulas, are plotted in Figure \ref{Figure:depths}.

The majority (51.94\%) of the unique formulas have exactly one \synt{FunctionCall} node ---they invoke one Excel function or they include one binary or unary operation. 18.18\% of the formulas have no such nodes, while 85.16\% have two or less. A small number of formulas (2,356) have more than 50 \synt{FunctionCall} nodes, and up to 239. Examining the utilization of constants, 47.1\% of the unique formulas do not include any, while 26.2\% include one or two constants. More than 10 constants are used in 0.95\% of the formulas, while 278 formulas were found to contain more than 50 and up to 209 constants.

The conditional depth of formulas is the number of nested conditional function calls that they include. We measured it as the depth of function-invoking parse tree nodes (\texttt{EXCEL-FUNCTION} and \texttt{REF-FUNCTION-COND}) created for conditional functions\footnote{Conditional functions are the \texttt{IF}, \texttt{COUNTIF}, \texttt{COUNTIFS}, \texttt{SUMIF}, \texttt{SUMIFS}, \texttt{AVERAGEIF}, \texttt{AVERAGEIFS} and \texttt{IFERROR}.}. Formula \texttt{ROUND(IF(D6>1600,D9,(1+(1600-IF(D6>D7,D6,D7))*D8)*D9),0)} (1), for example, has a conditional depth of 2. We found that 7,549,671 (88.02\%) of the formulas in the datasets do not include any conditional function call and 805,359 (9.39\%) include only one. On the opposite end, 7,791 formulas include 5 or more nested conditional function calls and 288 parse trees have conditional depth over 20.
 
 \begin{figure}
 	\centering
 	
 	 	\begin{subfigure}[b]{0.49\textwidth}
 	 		\centering 
 	 		\includegraphics[width=1\textwidth]{img/freqsBasic}
 	 		\caption{Number of functions and constants}
 	 		\label{fig:freqsBasic}
 	 	\end{subfigure}
 	 	~
 	\begin{subfigure}[b]{0.49\textwidth}
 		\centering
 		\includegraphics[width=1\textwidth]{img/depths4}
 		\caption{Depth of conditional function nodes}
 		\label{fig:depthConditional}
 	\end{subfigure}
 	~
 	
 	\begin{subfigure}[b]{0.49\textwidth}
 		\centering
 		\includegraphics[width=1\textwidth]{img/depths2}
 		\caption{Depth of \synt{Formula} nodes}
 		\label{fig:depthFormula}
 	\end{subfigure}
 	~
 	\begin{subfigure}[b]{0.49\textwidth}
 		\centering
 		\includegraphics[width=1\textwidth]{img/depths3}
 		\caption{Depth of function-invoking nodes}
 		\label{fig:depthOperator}
 	\end{subfigure}
 	\caption{Complexity indicators for the unique formulas in the four datasets combined (vertical axes are in logarithmic scale)}\label{Figure:depths}
 \end{figure}
 
The formula depth and the operator depth are indicators of the formula complexity in terms of calculation operations. The first is the depth of \synt{Formula} nodes in the tree, while the latter of function-invoking  \synt{FunctionCall}, \synt{RefFunctionCall} and \texttt{UDF} nodes. In the example in Figure \ref{figure:ourparsetree}, those are 2 and 1 respectively. The majority of the formulas in the dataset are as simple as this example or simpler: 68.72\% of the parse trees have formula depth up to 2, and 55,2\% have operator depth 0 or 1. However, as shown in Figures \ref{fig:depthFormula} and \ref{fig:depthOperator}, significantly complex formulas have also been found. 52,539 trees have formula depth greater than 11 and 79,885 trees have operator depth greater than 8, which are the formula and operator depths of formula (1). All formulas with operator depths over 65 involve simple but repetitive operations (additions, string concatenations or multiplications) of a large group of numbers or cells. For example, the formula with the largest operator depth of 208 is \texttt{320+204+...+616}, adding a total of 209 numbers.
 
 \noindent
 \fbox{
 	\begin{minipage}{0.98\textwidth}
 		RQ1: The majority of Excel formulas are small and simple: 70\% of the unique formulas in the datasets include up to one function or operation and up to two constants. 88\% of the unique formulas in the datasets do not invoke conditional functions. There exist surprisingly large and complex formulas. These include formulas that invoke simple but repetitive operations, but also formulas with many nested conditional functions.
 	\end{minipage}}
 	
\subsection{Functions and Operations}
\begin{sidewaystable*}
	\vspace{2mm}
	\caption{Frequency of spreadsheet formulas with specific grammatical structures in the combined EUSES, Enron, Fuse and WikiLeaks datasets}
	\label{table:occurences}
	\centering
	\input{floats/table-occurences}
\end{sidewaystable*}

Table \ref{table:occurences} shows the number of parsed formulas in the four datasets that contain each type of parse tree node. All parsed formulas contain at least one \synt{Formula} node. 86.61\% of the formulas include a \synt{FunctionCall}. Built-in value-returning functions are invoked by 42.70\% of the formulas, the majority of which contain exactly one function call. This is derived from the data plotted in Figure \ref{fig:nodesFunctions}, showing the number of \texttt{EXCEL-FUNCTION} nodes in the parse trees of the unique formulas in datasets. We found that 6.13\% of the unique formulas contain two or more of such nodes.The largest number of \texttt{EXCEL-FUNCTION} nodes was found in a 1.231 character-long formula that invoked repetitively 7 distinct functions for a total of 91 times.

A significant amount of formulas (1,963,284	or 1.04\%) invoke user-defined functions---e.g., \texttt{=erUserEmail(User_Id)}. A special case of user defined functions are the ones created using an Excel add-in. These are invoked as \texttt{_xll.functionName} in 0.65\% of the formulas.

Operators are common, with binary operators appearing in 48.58\% of the formulas and 18.47\% of the formulas containing prefix operators. Figure \ref{fig:nodesFunctions} plots the number of operators of each type. Exactly one binary operator is found in 24.69\% of the unique formulas, 9.77\% have two or three and 3.95\% have more than three and up to 239.

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=1\textwidth]{img/nodesFunctions}
		\caption{\synt{FunctionCall}-related nodes}
		\label{fig:nodesFunctions}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=1\textwidth]{img/nodesConstants}
		\caption{\synt{Constant}-related nodes}
		\label{fig:nodesConstants}
	\end{subfigure}
	
	\caption{Frequency of different types of functions, operations and constants in the parse trees of the unique formulas in the four datasets combined (vertical axes are in logarithmic scale)}
\end{figure}

Table \ref{table:functions} lists the most frequently used functions and the operators, along with their total occurrences in the unique formulas of the four datasets combined. The frequency of operators is similar across datasets, with the plus being the most popular one in all four. The frequency of functions varies, with \texttt{IF} and \texttt{SUM} being the ones in the top-ten most frequently appearing in all four datasets. From the top-five functions in each dataset, the ones that are missing from the table are the \texttt{AVERAGE} (fifth most frequent function in the Enron dataset) and the \texttt{INDIRECT} (third most frequent one in the Euses dataset). Examining the most rarely used Excel build-in functions, we find that \texttt{STEYX}, \texttt{VARA}, \texttt{CONVERT}, \texttt{EXPONDIST}, \texttt{WEIBULL}, \texttt{BETADIST} and \texttt{COSH} are used only one time each, the first two in the Euses and the remainder in the Fuse dataset.

\begin{table}[]
	\centering
	\caption{Frequency of the most common functions and operators found in the unique formulas of the four datasets}
	\label{table:functions}
	\input{floats/table-functions}
\end{table}

Regarding function arguments, spreadsheet systems allow empty arguments (e.g. \texttt{=SUM(,E35,E37)}) but this is rarely done---in only 0.17\% of the formulas. In the EUSES and Fuse datasets we also found 743 cases of constant arrays used as arguments, e.g. \texttt{=FVSCHEDULE(1,\{0.09;0.11;0.1\})}. Reserved names are uncommon, with 667 occurrences of the \texttt{_xlnm.Print_Area} and 5 occurrences of \texttt{_xlnm.Database}.

Analyzing the utilization of constants in formulas, we find that 42.35\% of the formulas contain at least one; more than one third (35.61\%) of the formulas contain a number and 13.39\% are formulas that contain text. Figure \ref{fig:nodesConstants} plots the number of constants of different types in the parse trees. One to four numbers is used in 27.18\% of the unique formulas and 0.56\% contain more than 10 numbers and up to 209 (was left out of the plot for readability). For textual constants, an interesting finding is that there are most commonly three of them in formulas ---19.09\% of the unique formulas contain three \texttt{STRING} tokens in their parse trees, while 9.38\% contain one or two.

Table \ref{table:constants} lists the most frequently used constants, along with their total occurrences in the unique formulas of the four datasets combined. The frequency of numerical constants is similar across datasets, but this is not the case with the non-numerical ones, with \texttt{FALSE} and \texttt{"-"} being the only ones in the top-twenty of all datasets.

\begin{table}[]
	\centering
	\caption{Frequency of the most common constants found in the unique formulas of the four datasets combined}
	\label{table:constants}
	\input{floats/table-constants}
\end{table}

The array formulas production rule, covering \synt{Formula}s surrounded by brackets, is the only part of the grammar that is not evaluated. The Gembox library that we use for reading spreadsheets does not support array formulas---it reads them as regular formulas, without the surrounding brackets. For this reason, we cannot we extract information on their frequency in the four datasets.

 \noindent
 \fbox{
 	\begin{minipage}{0.98\textwidth}
 		RQ2: 87\% of the total formulas in the datasets include at least one function or operation: 43\% of the formulas include Excel value-returning functions, with  \texttt{IF} and \texttt{SUM} being common in all datasets, 49\% include binary operations, with addition being by far the most common one, and 18\% include prefix operators. User-defined functions are found in 1\% of the formulas. 42\% of the total formulas contain at least one constant, usually a number, with 0 being the most common one.
 	\end{minipage}}

\subsection{Input Data}
Spreadsheet formula calculations can be performed using data from other cells, internal or external, local or in different sheets. This data is used in formulas by specifying references to these cells. 98.92\% of the formulas in the four datasets contain at least one \synt{Reference}. Figure \ref{fig:nodesReference} plots the number of references in the parse trees of the unique formulas. One or, more commonly, two reference nodes are found in the parse trees of the majority of the formulas (in 64.61\%), while 1.82\% have more than 10 reference nodes and up to 235.

As explained in Section \ref{subsec:references}, references can include cell ranges, which can be constructed by three operators: the range operator \texttt{:}, the union operator \texttt{,}, and the intersection operator \texttt{\char32}. The range operator is the most common one, with 24.32\% of the formulas including at least one instance of it. In the four datasets, intersection operations are found in 225,621 formulas (0.12\%), the majority of which (80\%) being in the Fuse dataset alone. Unions are found in only 578 formulas, e.g. \texttt{=LARGE((F38,C38),1)}. The majority of the occurrences are arguments of the \texttt{LARGE},  \texttt{SMALL} and \texttt{RANK} functions---these functions require a range of cells to be declared as a single argument, necessitating a union if the cells are not in a single range. 

References to named ranges exist in 1.79\% of formulas. The Enron dataset differs significantly from the other ones in this aspect, having named ranges in 7.24\% of its formulas. While most formulas with named ranges refer to only one, there exist complex cases: 3.215  unique formulas were found with more than 10 \synt{NamedRange} nodes, and even 6 with more than 100.

28.53\% of the total formulas contain a reference that is not local, since it includes a \synt{Prefix}. External file references exist in 8.32\% of the formulas.  Figure \ref{fig:nodesPrefix} plots the number of \synt{Prefix} nodes in the parse trees of the unique formulas. Most formulas that utilize prefixed references have exactly one \texttt{SHEET} or \texttt{FILE} node in their parse trees. Only 1.07\% of the unique formulas include more than one external file references and up to 34, although all references in this case were to the same external file.

Interestingly, horizontal and vertical ranges are rarely used (in 0.07\% and 4.19\% of the formulas respectively), especially in the Enron and the Euses datasets, where they appear jointly in 0.25\% of the formulas. 0.76\% of formulas include references to errors, e.g. \texttt{=\#REF!E3}. These reference errors are by far the most common type of error ---the \texttt{ERROR} token exists in only 0.02\% of the formulas.

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=1\textwidth]{img/nodesReference}
		\caption{\synt{Reference}-related nodes}
		\label{fig:nodesReference}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=1\textwidth]{img/nodesPrefix}
		\caption{\synt{Prefix}-related nodes}
		\label{fig:nodesPrefix}
	\end{subfigure}
	
	\caption{Frequency of references and prefixes in the parse trees of the unique formulas in the four datasets combined (vertical axes are in logarithmic scale)}
\end{figure}

Moving to the edge cases of the grammar, the structures that are least common in the datasets include:
\begin{description}
	\item[File-only external references] \hfill \\
	External references are normally in the form \texttt{[File]Sheet!Cell}. In 171,048 formulas (0.09\%), however, the sheet is not specified, e.g. \texttt{=[2]!LastTrade}. These are cases of references to either external named ranges or external UDFs.
	\item[References to external UDFs] \hfill \\
	139,851 formulas (0.07\%) contain references to external UDFs, for example \texttt{=[1]!SheetName()}.
	\item[Structured references] \hfill \\
	54,153 formulas (0.03\%) from the Fuse and the WikiLeaks datasets contain this relatively new type of reference, introduced in Excel 2007. An example is \texttt{tblData[[\#This Row],[Year]]}, returning the value of the cell in the current row of the defined table \texttt{tblData} in the table column with header \texttt{Year}.
	\item[Multiple sheet references] \hfill \\
	25,218 formulas (0.01\%) contain this complex case of reference, which spans across multiple sheets. An example formula is \texttt{=SUM(Sheet1:Sheet10!A5)}, evaluated by summing all cells in position A5 from Sheet1 to Sheet10. In 1,054 formulas, the reference is to external files.
	\item[Complex ranges]  \hfill \\
	9,166 formulas (0.005\%) contain \synt{Reference}s that include more than two or different types of \texttt{':'} separated \synt{ReferenceItem}s. An example is range \texttt{B2:D4:C1:C5}, illustrated in Figure \ref{fig:complexA}, which is equivalent to \texttt{B1:D5}. The range limits in complex ranges are not the ones specified in the formula: they are calculated as the upper leftmost and lower rightmost cell in the square that includes all defined cells. Understanding these limits is even less intuitive when vertical or horizontal ranges or named ranges are used, like in Figure \ref{fig:complexB}. The majority (95\%) of the complex ranges in the dataset are defined using three cell locations.
	\begin{figure}
		\centering
		\begin{subfigure}[b]{0.49\textwidth}
			\centering
			\includegraphics[width=1\textwidth]{img/complexRanges}
			\caption{A range with four limits \texttt{B2:D4:C1:C5}, equivalent to the area marked gray \texttt{B1:D5}}
			\label{fig:complexA}
		\end{subfigure}
		~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
		%(or a blank line to force the subfigure onto a new line)
		\begin{subfigure}[b]{0.49\textwidth}
			\centering
			\includegraphics[width=1\textwidth]{img/complexNamedRanges}
			\caption{A range with a named range \texttt{rangeC2D3:B1}, equivalent to the area marked gray \texttt{A1:C3}}
			\label{fig:complexB}
		\end{subfigure}
		\caption{Examples of references to complex ranges}\label{Figure:ComplexRanges}
	\end{figure}	
	\item[Prefixed right limits] \hfill \\
	3,941 formulas (0.002\%) include a reference with a prefix in the right limit, e.g. \texttt{=SUM('Deals'!F9:'Deals'!F16)}, which is equivalent to \texttt{=SUM('Deals'!F9:F16)}. In all cases this prefix is identical to the first one, as continuous ranges spanning across multiple sheets are not supported by Excel. Still, this syntax is supported.
\end{description}

Examining the special case of Excel functions that return references (the \texttt{INDEX}, \texttt{OFFSET} and \texttt{INDIRECT}), they are found in 1.04\% of the formulas, with the most common one being the \texttt{INDEX} (in 0.69\% of formulas) and the least common one being the \texttt{OFFSET} (in 0.10\%).
While the \texttt{IF} and \texttt{CHOOSE} functions can be part of reference expressions, there were no formulas in the datasets using them as such.
An example of using those functions in this way would be \texttt{=SUM(IF(A1=1,A2,A5):A10)}, which is equivalent to \texttt{=SUM(A2:A10)} if \texttt{A1} is \texttt{1} and to \texttt{=SUM(A5:A10)} otherwise.

Another rare case of references are the dynamic data exchange links, recognized using token \texttt{DDECALL}, which were found in 3,686 formulas of the Enron and the Euses datasets and in only 3 formulas of the other two. These take the form of \texttt{=Program|Topic!Arguments}, e.g. \texttt{=Database|TableA!Column1}, and are used in Windows versions of Microsoft Excel to receive  data from other applications.

 \noindent
 \fbox{
 	\begin{minipage}{0.98\textwidth}
 		RQ3: Almost all formulas (98\%) use data from other cells, through various types of references. References in the form of cell ranges are used in one fourth of the formulas, but unions and intersections are rare. 29\% of the formulas refer to cells outside their worksheet, and even 8\% of the formulas include references to cells in external files. References to named ranges, to horizontal and vertical ranges and to reference-returning Excel functions are rare. In less than 0.1\% of the formulas we found multiple sheet references, complex ranges, structured references or dynamic data exchange links.
 	\end{minipage}}

\section{Discussion and Limitations}
\label{sec:discussion}
The currently defined formula grammar is able to parse 99,99\% of the 8,577,426 unique formulas in the four datasets. In this section, we discuss a variety of issues that affect its applicability and suitability.

\subsection{Dialects}

While other spreadsheet programs (e.g. Numbers, LibreOffice, Google Sheets) have generally adopted the Excel formula syntax, there are slight differences between these programs and even between Excel versions.
Our grammar has been designed as a generically as possible and has been enriched to include all syntactical features found in the four datasets.
All datasets, however, contain spreadsheets created in, or converted to, the Excel 2007 format, as explained in Section \ref{sec:evaluation}.
The conversion does not affect the function names of previous Excel versions that have been deprecated after Excel 2007, but it does affect deprecated syntactical features like labels or regular expressions, which are described below. This limits the grammar support for language elements that are spreadsheet system-dependent or even version-dependent.

Certain differences between spreadsheet systems or versions are irrelevant to the grammar; for example, differences in the number or the type of built-in function arguments would not affect the grammar. However, other differences will require grammar adjustment. Examples are new syntactical features, like the structured references that were introduced in Excel 2010 and the grammar was adjusted to support, and changes in the built-in functions list, which would make the parser mistakenly recognize built-in functions as user-defined functions.
Another example is found in LibreOffice, which uses \texttt{\~} as the union operator instead of \texttt{,}.
The presented grammar will need to be modified to account for these differences before it can be used on other dialects.

Syntactical features have also been deprecated between Excel versions.
An example is regular expressions in formulas.
Excel allows defining formulas that include regular expressions, for example \texttt{=SUM('S*'!A1)} or \texttt{=SUM('Sheet?'!A1)}.
However, in Excel 2010 and up, regular expressions are instantly resolved---in the example, to  \texttt{=SUM(Sheet2:Sheet3!A1)}, summing up all A1 cells between Sheet2 and Sheet3, where the sheets are all sheets matching the regular expression, except the one that the formula is on.
This way, in Excel versions 2010 and up, saved spreadsheets never contain regular expressions.
\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{img/labels}
	\caption{A natural language formula in Excel 2003}
	\label{fig:labels}
\end{figure}

The use of labels in formulas (referred to as natural language formulas) is another feature that was discontinued from Excel 2007 onwards.
Labels were the headings that were typed above columns and before rows, and they could be used in formulas instead of defined names or cell ranges.
Figure \ref{fig:labels} shows an example in Excel 2003, where formula \texttt{=Product A Store 2} returns the intersection between the cell range with heading \texttt{Product A} and the one with heading \texttt{Store 2}.
This feature is replaced in newer versions of Excel with the less error-prone named ranges feature.
When processing spreadsheets with newer versions of Excel, the references that include labels are automatically converted to cell-only references---in the example, the formula is converted to \texttt{=C2}.
Our grammar does not support labels, and it would mistakenly parse them as named ranges.

\subsection{Internationalization}

The presentation of Excel formulas to the user differs depending on the language settings of the software. For example, function arguments are separated by a semicolon instead of a comma in locales that use the comma as a decimal separator: the formula \texttt{=SUM(1.5,A1)} in the English version would be shown as \texttt{=SOM(1,5;A1)} in the Dutch version.
Our grammar supports only the English locale.
Grammars for other locales can be derived by replacing delimiters, error values and function names with their localized versions.

It is worth noting that Excel will always save formulas in either a locale-independent form (Excel 2003 and earlier format) or in its English version (Excel 2007 and later format). When interacting with Excel through its API two versions of the formula can be read or written: the English version and the version in the current locale.
This makes a grammar for the English version useful, since the parser can process all spreadsheets as long as their formulas are read using the always available English locale.

\subsection{Rejection of Invalid Formulas}

As stated in the design goals in Section \ref{sec:designgoals}, the goal of this grammar is to facilitate analysis of formulas, which means correctly parsing valid spreadsheet formulas.
Rejecting invalid formulas is not among the primary goals of this grammar, as the parser will normally not encounter invalid formulas in Excel files.
Furthermore, while there exist four big datasets of valid formulas, no such datasets of invalid formulas exist.
As such, we expect that the presented grammar will parse formulas which are not valid.
Using this grammar to parse possibly-invalid formulas like user-input might thus require additional safeguards.

On one point we know the grammar to be too broad: Excel places several limitation on formulas like the number of arguments of a function (255), nested function calls (64), row number ($2^{20}$), column number ($2^{14}$) and total formula length ($2^{13}$), with lower numbers in older file formats.
Our grammar does not enforce any of these limits.

\subsection{Parse Tree Correctness}

While we have empirically shown a high compatibility in terms of successful parse rate, we do not have as much evidence that the produced parse trees are correct as this is only tested by usage and unit tests in the reference implementation. We have manually sampled numerous parse trees and we have found them to be correct. We believe it is unlikely that a formula parsed with the presented grammar would be interpreted differently by Excel, but we do seek additional feedback on possible erroneous parse trees from the research community \footnote{\url{https://github.com/spreadsheetlab/XLParser/issues}}.

\section{Related Work}
\label{section:relatedWork}
Efforts to reverse-engineer language characteristics based on existing artifacts have been successful for other languages, including COBOL \cite{van1997obtaining} and C, C++, C\# and Java \cite{zaytsev2010recovery}.

Most related to our research on the spreadsheet formula language is the work of Badame and Dig~\cite{badame2012refactoring} who, as part of their proposed spreadsheet refactoring approach, presented a grammar for spreadsheet formulas. However, they do not evaluate their grammar, and upon inspection one can see that key ingredients are missing: e.g. external references, intersections, unions, named ranges and operator precedence. An extension of the same grammar was used to refactor formulas by Hermans and Dig \cite{hermans2014bumblebee}.

There exist other works that analyze spreadsheets and their formulas, but the analysis is limited to a single dataset. \cite{euses} presents the EUSES dataset, along with summary statistics on its formula functions, input cells and data types, which are obtained using the Excel VBA API. A similar analysis for the Enron dataset is presented in \cite{enron}, using data that was obtained with a previous version of the parser proposed in this paper.

Furthermore, there is a large body of related work that relies on parsing spreadsheet formulas to analyze spreadsheets. This includes our own work, in which we have created an algorithm to visualize spreadsheets as dataflow diagrams \cite{DBLP:conf/icse/HermansPD11}, and subsequently on detecting smells in spreadsheets \cite{DBLP:conf/icse/HermansPD12,DBLP:conf/icsm/Hermans212} and on applying testing practices on spreadsheets \cite{Expector}. Related approaches exist, for example the work of Cunha et al. that have worked on code smells~\cite{iccsa12} and smell-based fault localization~\cite{conf/icsme/CunhaFMPS14} and the work of Cheung et al. on cell clustering and smell detection \cite{custodes}. These papers also analyze spreadsheet formulas but do not detail which analysis method or grammar they use for formula parsing. The table clone detection mechanism recently presented by Dou et al. in \cite{Dou2016} relies on detecting the similarity between spreadsheet formulas, but utilizes string comparison of their R1C1 representation, along with undefined techniques for recognizing constants and external references.

\section{Conclusion}
\label{section:conclusion}
In this paper we (1) present a grammar for spreadsheet formulas, (2) evaluate it against over eight million unique formulas, successfully parsing 99.99\%, and (3) use it to analyze the formulas in the dataset in terms of complexity, functionality and utilization of data.

The grammar is compact and produces processable parse trees, suited for further manipulation and analysis. We believe that the grammar is reliable and concise enough to facilitate further research on spreadsheet formula codebases. It has already been applied in other works for analyzing formula characteristics, calculation chains and code smells and for applying formula transformations. The XLParser is published as open-source software.

A point of improvement for the grammar is that its exact compatibility with the official Excel grammar is unknown.
A comparison to the official specification could lead to either improving compatibility, or extending the number of known limitations.
In general, the problem of determining whether two context-free grammars are equivalent is undecidable, but in practice several techniques have been successfully used for this purpose \cite{lammel2009introduction,fischer2012comparison}.

The analysis of the formulas in the dataset revealed that the majority are small and simple, but also that surprisingly large and complex formulas, with more than 50 functions or operations, exist.
In terms of functionality, the majority of the formulas include at least one function or operation and almost half of them contain at least one constant.
Almost all formulas were found to use data from other cells, which are often to cells of different worksheets and of external files.
Various types of references were found: References in the form of cell ranges are used often, in one fourth of the formulas, but unions, intersections, and references to named ranges, to horizontal and vertical ranges and to reference-returning Excel functions are rare.
In less than 0.1\% of the formulas we found multiple sheet references, complex ranges, structured references or dynamic data exchange links.

\bibliographystyle{wileyj}
\bibliography{XLGrammarRefs}

\end{document}
